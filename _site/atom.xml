<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>Yangming.com</title>
   <link href="http://yangm90.github.io/Blog//atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://yangm90.github.io/Blog/" rel="alternate" type="text/html" />
   <updated>2015-01-10T17:23:08+08:00</updated>
   <id>http://yangm90.github.io/Blog/</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>关于android的Activity是如何触摸事件框架简析(二)</title>
     <link href="http://beiyuu.com/AndroidTouch1"/>
     <updated>2015-01-08T00:00:00+08:00</updated>
     <id>http://beiyuu.com/AndroidTouch1</id>
     <content type="html">&lt;p&gt;上次分析了touch事件如何传到我们的View上面了，这次分析下View是如何做分发的.
从最基本的View层次分析&lt;/p&gt;

&lt;h3&gt;View的事件分发&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;/**
     * Pass the touch screen motion event down to the target view, or this
     * view if it is the target.
     *
     * @param event The motion event to be dispatched.
     * @return True if the event was handled by the view, false otherwise.
     */
    public boolean dispatchTouchEvent(MotionEvent event) {
        if (mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onTouchEvent(event, 0);
        }

        if (onFilterTouchEventForSecurity(event)) {
            //noinspection SimplifiableIfStatement
            ListenerInfo li = mListenerInfo;
            if (li != null &amp;amp;&amp;amp; li.mOnTouchListener != null &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED
                    &amp;amp;&amp;amp; li.mOnTouchListener.onTouch(this, event)) {
                return true;
            }

            if (onTouchEvent(event)) {
                return true;
            }
        }

        if (mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
        }
        return false;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最先调用的是onTouch事件,如果onTouch返回True,则直接返回了,在分析下onTouchEvent发生了什么事情:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;/**
     * Implement this method to handle touch screen motion events.
     *
     * @param event The motion event.
     * @return True if the event was handled, false otherwise.
     */
    public boolean onTouchEvent(MotionEvent event) {
        final int viewFlags = mViewFlags;

        if ((viewFlags &amp;amp; ENABLED_MASK) == DISABLED) {
            if (event.getAction() == MotionEvent.ACTION_UP &amp;amp;&amp;amp; (mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0) {
                setPressed(false);
            }
            // A disabled view that is clickable still consumes the touch
            // events, it just doesn&amp;#39;t respond to them.
            return (((viewFlags &amp;amp; CLICKABLE) == CLICKABLE ||
                    (viewFlags &amp;amp; LONG_CLICKABLE) == LONG_CLICKABLE));
        }
        if (mTouchDelegate != null) {
            if (mTouchDelegate.onTouchEvent(event)) {
                return true;
            }
        }
        if (((viewFlags &amp;amp; CLICKABLE) == CLICKABLE ||
                (viewFlags &amp;amp; LONG_CLICKABLE) == LONG_CLICKABLE)) {
            switch (event.getAction()) {
                case MotionEvent.ACTION_UP:
                    boolean prepressed = (mPrivateFlags &amp;amp; PFLAG_PREPRESSED) != 0;
                    if ((mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0 || prepressed) {
                        // take focus if we don&amp;#39;t have it already and we should in
                        // touch mode.
                        boolean focusTaken = false;
                        if (isFocusable() &amp;amp;&amp;amp; isFocusableInTouchMode() &amp;amp;&amp;amp; !isFocused()) {
                            focusTaken = requestFocus();
                        }

                        if (prepressed) {
                            // The button is being released before we actually
                            // showed it as pressed.  Make it show the pressed
                            // state now (before scheduling the click) to ensure
                            // the user sees it.
                            setPressed(true);
                       }

                        if (!mHasPerformedLongPress) {
                            // This is a tap, so remove the longpress check
                            removeLongPressCallback();

                            // Only perform take click actions if we were in the pressed state
                            if (!focusTaken) {
                                // Use a Runnable and post this rather than calling
                                // performClick directly. This lets other visual state
                                // of the view update before click actions start.
                                if (mPerformClick == null) {
                                    mPerformClick = new PerformClick();
                                }
                                if (!post(mPerformClick)) {
                                    performClick();
                                }
                            }
                        }

                        if (mUnsetPressedState == null) {
                            mUnsetPressedState = new UnsetPressedState();
                        }

                        if (prepressed) {
                            postDelayed(mUnsetPressedState,
                                    ViewConfiguration.getPressedStateDuration());
                        } else if (!post(mUnsetPressedState)) {
                            // If the post failed, unpress right now
                            mUnsetPressedState.run();
                        }
                        removeTapCallback();
                    }
                    break;

                case MotionEvent.ACTION_DOWN:
                    mHasPerformedLongPress = false;

                    if (performButtonActionOnTouchDown(event)) {
                        break;
                    }

                    // Walk up the hierarchy to determine if we&amp;#39;re inside a scrolling container.
                    boolean isInScrollingContainer = isInScrollingContainer();

                    // For views inside a scrolling container, delay the pressed feedback for
                    // a short period in case this is a scroll.
                    if (isInScrollingContainer) {
                        mPrivateFlags |= PFLAG_PREPRESSED;
                        if (mPendingCheckForTap == null) {
                            mPendingCheckForTap = new CheckForTap();
                        }
                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                    } else {
                        // Not inside a scrolling container, so show the feedback right away
                        setPressed(true);
                        checkForLongClick(0);
                    }
                    break;

                case MotionEvent.ACTION_CANCEL:
                    setPressed(false);
                    removeTapCallback();
                    removeLongPressCallback();
                    break;

                case MotionEvent.ACTION_MOVE:
                    final int x = (int) event.getX();
                    final int y = (int) event.getY();

                    // Be lenient about moving outside of buttons
                    if (!pointInView(x, y, mTouchSlop)) {
                        // Outside button
                        removeTapCallback();
                        if ((mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0) {
                            // Remove any future long press/tap checks
                            removeLongPressCallback();

                            setPressed(false);
                        }
                    }
                    break;
            }
            return true;
        }

        return false;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里值得注意的就是两个点:
1. onclick事件是在MotionEvent.ACTION_UP的时候返回的，是在onTouch事件之后
2. onTouchEvent返回值为True，才能接受到以后的事件，如果返回false则收不到。&lt;/p&gt;

&lt;h3&gt;ViewGroup的事件分发&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;/**
     * {@inheritDoc}
     */
    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
        }

        boolean handled = false;
        if (onFilterTouchEventForSecurity(ev)) {
            final int action = ev.getAction();
            final int actionMasked = action &amp;amp; MotionEvent.ACTION_MASK;

            // Handle an initial down.
            if (actionMasked == MotionEvent.ACTION_DOWN) {
                // Throw away all previous state when starting a new touch gesture.
                // The framework may have dropped the up or cancel event for the previous gesture
                // due to an app switch, ANR, or some other state change.
                cancelAndClearTouchTargets(ev);
                resetTouchState();
            }

            // Check for interception.
            final boolean intercepted;
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
                final boolean disallowIntercept = (mGroupFlags &amp;amp; FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
            }

            // Check for cancelation.
            final boolean canceled = resetCancelNextUpFlag(this)
                    || actionMasked == MotionEvent.ACTION_CANCEL;

            // Update list of touch targets for pointer down, if needed.
            final boolean split = (mGroupFlags &amp;amp; FLAG_SPLIT_MOTION_EVENTS) != 0;
            TouchTarget newTouchTarget = null;
            boolean alreadyDispatchedToNewTouchTarget = false;
            if (!canceled &amp;amp;&amp;amp; !intercepted) {
                if (actionMasked == MotionEvent.ACTION_DOWN
                        || (split &amp;amp;&amp;amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                    final int actionIndex = ev.getActionIndex(); // always 0 for down
                    final int idBitsToAssign = split ? 1 &amp;lt;&amp;lt; ev.getPointerId(actionIndex)
                            : TouchTarget.ALL_POINTER_IDS;

                    // Clean up earlier touch targets for this pointer id in case they
                    // have become out of sync.
                    removePointersFromTouchTargets(idBitsToAssign);

                    final int childrenCount = mChildrenCount;
                    if (childrenCount != 0) {
                        // Find a child that can receive the event.
                        // Scan children from front to back.
                        final View[] children = mChildren;
                        final float x = ev.getX(actionIndex);
                        final float y = ev.getY(actionIndex);

                        final boolean customOrder = isChildrenDrawingOrderEnabled();
                        for (int i = childrenCount - 1; i &amp;gt;= 0; i--) {
                            final int childIndex = customOrder ?
                                    getChildDrawingOrder(childrenCount, i) : i;
                            final View child = children[childIndex];
                            if (!canViewReceivePointerEvents(child)
                                    || !isTransformedTouchPointInView(x, y, child, null)) {
                                continue;
                            }

                            newTouchTarget = getTouchTarget(child);
                            if (newTouchTarget != null) {
                                // Child is already receiving touch within its bounds.
                                // Give it the new pointer in addition to the ones it is handling.
                                newTouchTarget.pointerIdBits |= idBitsToAssign;
                                break;
                            }

                            resetCancelNextUpFlag(child);
                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                // Child wants to receive touch within its bounds.
                                mLastTouchDownTime = ev.getDownTime();
                                mLastTouchDownIndex = childIndex;
                                mLastTouchDownX = ev.getX();
                                mLastTouchDownY = ev.getY();
                                newTouchTarget = addTouchTarget(child, idBitsToAssign);
                                alreadyDispatchedToNewTouchTarget = true;
                                break;
                            }
                        }
                    }

                    if (newTouchTarget == null &amp;amp;&amp;amp; mFirstTouchTarget != null) {
                        // Did not find a child to receive the event.
                        // Assign the pointer to the least recently added target.
                        newTouchTarget = mFirstTouchTarget;
                        while (newTouchTarget.next != null) {
                            newTouchTarget = newTouchTarget.next;
                        }
                        newTouchTarget.pointerIdBits |= idBitsToAssign;
                    }
                }
            }

            // Dispatch to touch targets.
            if (mFirstTouchTarget == null) {
                // No touch targets so treat this as an ordinary view.
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
            } else {
                // Dispatch to touch targets, excluding the new touch target if we already
                // dispatched to it.  Cancel touch targets if necessary.
                TouchTarget predecessor = null;
                TouchTarget target = mFirstTouchTarget;
                while (target != null) {
                    final TouchTarget next = target.next;
                    if (alreadyDispatchedToNewTouchTarget &amp;amp;&amp;amp; target == newTouchTarget) {
                        handled = true;
                    } else {
                        final boolean cancelChild = resetCancelNextUpFlag(target.child)
                        || intercepted;
                        if (dispatchTransformedTouchEvent(ev, cancelChild,
                                target.child, target.pointerIdBits)) {
                            handled = true;
                        }
                        if (cancelChild) {
                            if (predecessor == null) {
                                mFirstTouchTarget = next;
                            } else {
                                predecessor.next = next;
                            }
                            target.recycle();
                            target = next;
                            continue;
                        }
                    }
                    predecessor = target;
                    target = next;
                }
            }

            // Update list of touch targets for pointer up or cancel, if needed.
            if (canceled
                    || actionMasked == MotionEvent.ACTION_UP
                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                resetTouchState();
            } else if (split &amp;amp;&amp;amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {
                final int actionIndex = ev.getActionIndex();
                final int idBitsToRemove = 1 &amp;lt;&amp;lt; ev.getPointerId(actionIndex);
                removePointersFromTouchTargets(idBitsToRemove);
            }
        }

        if (!handled &amp;amp;&amp;amp; mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
        }
        return handled;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;代码很长，但是阅读完我们可以发现几点问题:
1.允许ViewGroup去做事件拦截通过方法onInterceptTouchEvent()，使用requestDisallowInterceptTouchEvent方法可以设置是否允许拦截touch事件。
2.onInterceptTouchEvent返回false的时候，会对事件进行分发，分发到子View上面。如果是某个子View是target,则调用子View的DdispatchTouchEvent，否则调用自身的super.dispatchTouchEvent方法。&lt;/p&gt;

&lt;h3&gt;Activity的事件分发&lt;/h3&gt;

&lt;p&gt;之前的文章就很明显的告诉我们ViewRootImpl会调用设置的mView，那么mView到底是什么呢？
回顾Activity代码:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;/**
     * Set the activity content from a layout resource.  The resource will be
     * inflated, adding all top-level views to the activity.
     *
     * @param layoutResID Resource ID to be inflated.
     * 
     * @see #setContentView(android.view.View)
     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
     */
    public void setContentView(int layoutResID) {
        getWindow().setContentView(layoutResID);
        initActionBar();
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里getWindow获取的是PhoneWindow的实例，其setContentView如下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Override
    public void setContentView(int layoutResID) {
        if (mContentParent == null) {
            installDecor();
        } else {
            mContentParent.removeAllViews();
        }
        mLayoutInflater.inflate(layoutResID, mContentParent);
        final Callback cb = getCallback();
        if (cb != null &amp;amp;&amp;amp; !isDestroyed()) {
            cb.onContentChanged();
        }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到传入的布局文件最终会展开并作为mContentParent的子View。那么mContentParent又是怎么产生的？看下installDecor方法：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;private void installDecor() {
        if (mDecor == null) {
            mDecor = generateDecor();
            mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
            mDecor.setIsRootNamespace(true);
            if (!mInvalidatePanelMenuPosted &amp;amp;&amp;amp; mInvalidatePanelMenuFeatures != 0) {
                mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);
            }
        }
        if (mContentParent == null) {
            mContentParent = generateLayout(mDecor);

            // Set up decor part of UI to ignore fitsSystemWindows if appropriate.
            mDecor.makeOptionalFitsSystemWindows();
            .......
        }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里通过generateLayout 创建了mContentParent，这个generateLayout是干嘛的呢？&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;protected ViewGroup generateLayout(DecorView decor) {
            ......
    // Inflate the window decor.

        int layoutResource;
        int features = getLocalFeatures();
        ......
        mDecor.startChanging();

        View in = mLayoutInflater.inflate(layoutResource, null);
        decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));

        ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
        if (contentParent == null) {
            throw new RuntimeException(&amp;quot;Window couldn&amp;#39;t find content container view&amp;quot;);
        }

        if ((features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_INDETERMINATE_PROGRESS)) != 0) {
            ProgressBar progress = getCircularProgressBar(false);
            if (progress != null) {
                progress.setIndeterminate(true);
            }
        }

        .........
        mDecor.finishChanging();
        return contentParent;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看出，Activity中，最上层为DecorView，mContentParent为DecorView中id为Window.ID_ANDROID_CONTENT的子View，而我们通过setContentView方法传入的布局文件则是mContentParent的子View。所以之前看过的mView，其实就是DecorView的一个实例，看下DecorView的dispatchTouchEvent:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Override
        public boolean dispatchKeyEvent(KeyEvent event) {
            if (!isDestroyed()) {
                final Callback cb = getCallback();
                final boolean handled = cb != null &amp;amp;&amp;amp; mFeatureId &amp;lt; 0 ? cb.dispatchKeyEvent(event)
                        : super.dispatchKeyEvent(event);
                if (handled) {
                    return true;
                }
            }

            return isDown ? PhoneWindow.this.onKeyDown(mFeatureId, event.getKeyCode(), event)
                    : PhoneWindow.this.onKeyUp(mFeatureId, event.getKeyCode(), event);
        }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的callback就是Activity，所以调用的就是Activity的dispatchKeyEvent().&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;/**
     * Called to process touch screen events.  You can override this to
     * intercept all touch screen events before they are dispatched to the
     * window.  Be sure to call this implementation for touch screen events
     * that should be handled normally.
     * 
     * @param ev The touch screen event.
     * 
     * @return boolean Return true if this event was consumed.
     */
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();
        }
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        return onTouchEvent(ev);
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;先调用的DecorView的superDispatchTouchEvent：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public boolean superDispatchTouchEvent(MotionEvent event) {
            return super.dispatchTouchEvent(event);
        }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里就算分析完了，DecorView其实就是一个FrameLayout。&lt;/p&gt;

&lt;h3&gt;结论&lt;/h3&gt;

&lt;p&gt;1.我们可以发现大体的顺序是这样的 Activity  ----&gt;  ViewGroup  ----&gt;  View 通过这样的模型进行消息分发的。
2. onTouch事件都是在 onTouchEvent之前的 设置为True了 事件就不会往下传。
3.修改onTouchEvent事件的返回值可能对下次的事件有影响，改为false可能以后都收不到了。&lt;/p&gt;

&lt;h3&gt;参考blog&lt;/h3&gt;
</content>
   </entry>
   
   <entry>
     <title>关于android的Activity是如何触摸事件框架简析(一)</title>
     <link href="http://beiyuu.com/AndroidTouch"/>
     <updated>2015-01-06T00:00:00+08:00</updated>
     <id>http://beiyuu.com/AndroidTouch</id>
     <content type="html">&lt;p&gt;最近做项目会修改导事件分发，所以对系统这部分代码进行了一定的研究，对android的框架的流的过程发出来供大家参考下.
所有代码研究基于android4.2.2_R1&lt;/p&gt;

&lt;h3&gt;Activity与windowMnager打交道的过程&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;首先是我们如何开启一个ActivityThread的，在ActivityThread中我们做了什么:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在ActivityThread中会最先调用的是handleLaunchActivity--&gt;handleResumeActivity;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward,
            boolean reallyResume) {
        .......
        if (r.window == null &amp;amp;&amp;amp; !a.mFinished &amp;amp;&amp;amp; willBeVisible) {
                r.window = r.activity.getWindow();
                View decor = r.window.getDecorView();
                decor.setVisibility(View.INVISIBLE);
                ViewManager wm = a.getWindowManager();
                WindowManager.LayoutParams l = r.window.getAttributes();
                a.mDecor = decor;
                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
                l.softInputMode |= forwardBit;
                if (a.mVisibleFromClient) {
                    a.mWindowAdded = true;
                    wm.addView(decor, l);
                }
        ......

    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;核心代码就是上面的通过windowManager添加View,
这里的wm实体其实是&lt;em&gt;WindowMnagerGlobal&lt;/em&gt;,查看addView:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
        
        ......
        ViewRootImpl root;
        View panelParentView = null;
        root = new ViewRootImpl(view.getContext(), display);
        view.setLayoutParams(wparams);
        ......
        // do this last because it fires off messages to start doing things
        try {
            root.setView(view, wparams, panelParentView);
        } catch (RuntimeException e) {
            // BadTokenException or InvalidDisplayException, clean up.
            synchronized (mLock) {
                final int index = findViewLocked(view, false);
                if (index &amp;gt;= 0) {
                    removeViewLocked(index, true);
                }
            }
            throw e;
        }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里是new出了一个新的ViewRootImpl调用了setView方法:
ViewRootImpl.java&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;/**
     * We have one child
     */
    public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
            ......
            try {
                    mOrigWindowType = mWindowAttributes.type;
                    mAttachInfo.mRecomputeGlobalAttributes = true;
                    collectViewAttributes();
                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mInputChannel);
                } catch (RemoteException e) {
                    mAdded = false;
                    mView = null;
                    mAttachInfo.mRootView = null;
                    mInputChannel = null;
                    mFallbackEventHandler.setView(null);
                    unscheduleTraversals();
                    setAccessibilityFocus(null, null);
                    throw new RuntimeException(&amp;quot;Adding window failed&amp;quot;, e);
                } finally {
                    if (restore) {
                        attrs.restore();
                    }
                }
            .......
            if (mInputChannel != null) {
                    if (mInputQueueCallback != null) {
                        mInputQueue = new InputQueue(mInputChannel);
                        mInputQueueCallback.onInputQueueCreated(mInputQueue);
                    } else {
                        mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,
                                Looper.myLooper());
                    }
                }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;核心代码就是 mWindowSession.addToDisplay(),&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Override
    public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,
            int viewVisibility, int displayId, Rect outContentInsets,
            InputChannel outInputChannel) {
        return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,
                outContentInsets, outInputChannel);
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就是一个aidl调用，最终是调用的WindowManagerService的addWindow方法：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public int addWindow(Session session, IWindow client, int seq,
            WindowManager.LayoutParams attrs, int viewVisibility, int displayId,
            Rect outContentInsets, InputChannel outInputChannel) {

        ......
        if (outInputChannel != null &amp;amp;&amp;amp; (attrs.inputFeatures
                    &amp;amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
                String name = win.makeInputChannelName();
                InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);
                win.setInputChannel(inputChannels[0]);
                inputChannels[1].transferTo(outInputChannel);

                mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);
            }
        ......
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里打开了一对inputChannel一个作为server端，一个作为client端，并且注册到inputManager里头.这个inputChannel其实就是pipe,我们看看他们是怎么生成的：
inputChannel.java&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;/**
     * Creates a new input channel pair.  One channel should be provided to the input
     * dispatcher and the other to the application&amp;#39;s input queue.
     * @param name The descriptive (non-unique) name of the channel pair.
     * @return A pair of input channels.  They are symmetric and indistinguishable.
     */
    public static InputChannel[] openInputChannelPair(String name) {
        if (name == null) {
            throw new IllegalArgumentException(&amp;quot;name must not be null&amp;quot;);
        }

        if (DEBUG) {
            Slog.d(TAG, &amp;quot;Opening input channel pair &amp;#39;&amp;quot; + name + &amp;quot;&amp;#39;&amp;quot;);
        }
        return nativeOpenInputChannelPair(name);
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;natvie层对应代码：
android_view_inputchannel.cpp&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;static jobjectArray android_view_InputChannel_nativeOpenInputChannelPair(JNIEnv* env,
        jclass clazz, jstring nameObj) {
    const char* nameChars = env-&amp;gt;GetStringUTFChars(nameObj, NULL);
    String8 name(nameChars);
    env-&amp;gt;ReleaseStringUTFChars(nameObj, nameChars);

    sp&amp;lt;InputChannel&amp;gt; serverChannel;
    sp&amp;lt;InputChannel&amp;gt; clientChannel;
    status_t result = InputChannel::openInputChannelPair(name, serverChannel, clientChannel);

    if (result) {
        String8 message;
        message.appendFormat(&amp;quot;Could not open input channel pair.  status=%d&amp;quot;, result);
        jniThrowRuntimeException(env, message.string());
        return NULL;
    }

    jobjectArray channelPair = env-&amp;gt;NewObjectArray(2, gInputChannelClassInfo.clazz, NULL);
    if (env-&amp;gt;ExceptionCheck()) {
        return NULL;
    }

    jobject serverChannelObj = android_view_InputChannel_createInputChannel(env,
            new NativeInputChannel(serverChannel));
    if (env-&amp;gt;ExceptionCheck()) {
        return NULL;
    }

    jobject clientChannelObj = android_view_InputChannel_createInputChannel(env,
            new NativeInputChannel(clientChannel));
    if (env-&amp;gt;ExceptionCheck()) {
        return NULL;
    }

    env-&amp;gt;SetObjectArrayElement(channelPair, 0, serverChannelObj);
    env-&amp;gt;SetObjectArrayElement(channelPair, 1, clientChannelObj);
    return channelPair;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;主要关注函数openInputChannelPair&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;status_t InputChannel::openInputChannelPair(const String8&amp;amp; name,
        sp&amp;lt;InputChannel&amp;gt;&amp;amp; outServerChannel, sp&amp;lt;InputChannel&amp;gt;&amp;amp; outClientChannel) {
    int sockets[2];
    if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets)) {
        status_t result = -errno;
        ALOGE(&amp;quot;channel &amp;#39;%s&amp;#39; ~ Could not create socket pair.  errno=%d&amp;quot;,
                name.string(), errno);
        outServerChannel.clear();
        outClientChannel.clear();
        return result;
    }

    int bufferSize = SOCKET_BUFFER_SIZE;
    setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &amp;amp;bufferSize, sizeof(bufferSize));
    setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &amp;amp;bufferSize, sizeof(bufferSize));
    setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &amp;amp;bufferSize, sizeof(bufferSize));
    setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &amp;amp;bufferSize, sizeof(bufferSize));

    String8 serverChannelName = name;
    serverChannelName.append(&amp;quot; (server)&amp;quot;);
    outServerChannel = new InputChannel(serverChannelName, sockets[0]);

    String8 clientChannelName = name;
    clientChannelName.append(&amp;quot; (client)&amp;quot;);
    outClientChannel = new InputChannel(clientChannelName, sockets[1]);
    return OK;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里就可以发现双方是通过一个共享内存，socket的方式通信。这时候我们就已经初步的了解 Activity与windowManagerService是如何建立联系的.&lt;/p&gt;

&lt;h3&gt;Activity接收事件过程&lt;/h3&gt;

&lt;p&gt;在ViewRootImpl中，我们会创建一个WindowInputEventReceiver，WindowInputEventReceiver的初始化会使用inputchannel和主线程的looper,继承于InputEventReceiver:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;**
     * Creates an input event receiver bound to the specified input channel.
     *
     * @param inputChannel The input channel.
     * @param looper The looper to use when invoking callbacks.
     */
    public InputEventReceiver(InputChannel inputChannel, Looper looper) {
        if (inputChannel == null) {
            throw new IllegalArgumentException(&amp;quot;inputChannel must not be null&amp;quot;);
        }
        if (looper == null) {
            throw new IllegalArgumentException(&amp;quot;looper must not be null&amp;quot;);
        }

        mInputChannel = inputChannel;
        mMessageQueue = looper.getQueue();
        mReceiverPtr = nativeInit(this, inputChannel, mMessageQueue);

        mCloseGuard.open(&amp;quot;dispose&amp;quot;);
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;会调用底层的nativeInit：
android_view_InputEventReceiver.cpp&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;static jint nativeInit(JNIEnv* env, jclass clazz, jobject receiverObj,
        jobject inputChannelObj, jobject messageQueueObj) {
    sp&amp;lt;InputChannel&amp;gt; inputChannel = android_view_InputChannel_getInputChannel(env,
            inputChannelObj);
    if (inputChannel == NULL) {
        jniThrowRuntimeException(env, &amp;quot;InputChannel is not initialized.&amp;quot;);
        return 0;
    }

    sp&amp;lt;MessageQueue&amp;gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);
    if (messageQueue == NULL) {
        jniThrowRuntimeException(env, &amp;quot;MessageQueue is not initialized.&amp;quot;);
        return 0;
    }

    sp&amp;lt;NativeInputEventReceiver&amp;gt; receiver = new NativeInputEventReceiver(env,
            receiverObj, inputChannel, messageQueue);
    status_t status = receiver-&amp;gt;initialize();
    if (status) {
        String8 message;
        message.appendFormat(&amp;quot;Failed to initialize input event receiver.  status=%d&amp;quot;, status);
        jniThrowRuntimeException(env, message.string());
        return 0;
    }

    receiver-&amp;gt;incStrong(gInputEventReceiverClassInfo.clazz); // retain a reference for the object
    return reinterpret_cast&amp;lt;jint&amp;gt;(receiver.get());
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里其实是拿到上层的looper和上层的inputchannel去生成一个NativeInputEventReceiver，在看看NativeInputEventReceiver的作用:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;NativeInputEventReceiver::NativeInputEventReceiver(JNIEnv* env,
        jobject receiverObj, const sp&amp;lt;InputChannel&amp;gt;&amp;amp; inputChannel,
        const sp&amp;lt;MessageQueue&amp;gt;&amp;amp; messageQueue) :
        mReceiverObjGlobal(env-&amp;gt;NewGlobalRef(receiverObj)),
        mInputConsumer(inputChannel), mMessageQueue(messageQueue),
        mBatchedInputEventPending(false) {
#if DEBUG_DISPATCH_CYCLE
    ALOGD(&amp;quot;channel &amp;#39;%s&amp;#39; ~ Initializing input event receiver.&amp;quot;, getInputChannelName());
#endif
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;status_t NativeInputEventReceiver::initialize() {
    int receiveFd = mInputConsumer.getChannel()-&amp;gt;getFd();
    mMessageQueue-&amp;gt;getLooper()-&amp;gt;addFd(receiveFd, 0, ALOOPER_EVENT_INPUT, this, NULL);
    return OK;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;NativeInputEventReceiver实际上就是生成了一个mInputConsumer,并且调用initialize，将inputChannel的fd挂载到looper中去监听事件，回调函数为handleEvent：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;int NativeInputEventReceiver::handleEvent(int receiveFd, int events, void* data) {
    if (events &amp;amp; (ALOOPER_EVENT_ERROR | ALOOPER_EVENT_HANGUP)) {
        ALOGE(&amp;quot;channel &amp;#39;%s&amp;#39; ~ Publisher closed input channel or an error occurred.  &amp;quot;
                &amp;quot;events=0x%x&amp;quot;, getInputChannelName(), events);
        return 0; // remove the callback
    }

    if (!(events &amp;amp; ALOOPER_EVENT_INPUT)) {
        ALOGW(&amp;quot;channel &amp;#39;%s&amp;#39; ~ Received spurious callback for unhandled poll event.  &amp;quot;
                &amp;quot;events=0x%x&amp;quot;, getInputChannelName(), events);
        return 1;
    }

    JNIEnv* env = AndroidRuntime::getJNIEnv();
    status_t status = consumeEvents(env, false /*consumeBatches*/, -1);
    mMessageQueue-&amp;gt;raiseAndClearException(env, &amp;quot;handleReceiveCallback&amp;quot;);
    return status == OK || status == NO_MEMORY ? 1 : 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env,
        bool consumeBatches, nsecs_t frameTime) {
    .......
        if (!skipCallbacks) {
            jobject inputEventObj;
            switch (inputEvent-&amp;gt;getType()) {
            case AINPUT_EVENT_TYPE_KEY:
#if DEBUG_DISPATCH_CYCLE
                ALOGD(&amp;quot;channel &amp;#39;%s&amp;#39; ~ Received key event.&amp;quot;, getInputChannelName());
#endif
                inputEventObj = android_view_KeyEvent_fromNative(env,
                        static_cast&amp;lt;KeyEvent*&amp;gt;(inputEvent));
                break;

            case AINPUT_EVENT_TYPE_MOTION:
#if DEBUG_DISPATCH_CYCLE
                ALOGD(&amp;quot;channel &amp;#39;%s&amp;#39; ~ Received motion event.&amp;quot;, getInputChannelName());
#endif
                inputEventObj = android_view_MotionEvent_obtainAsCopy(env,
                        static_cast&amp;lt;MotionEvent*&amp;gt;(inputEvent));
                break;

            default:
                assert(false); // InputConsumer should prevent this from ever happening
                inputEventObj = NULL;
            }

            if (inputEventObj) {
#if DEBUG_DISPATCH_CYCLE
                ALOGD(&amp;quot;channel &amp;#39;%s&amp;#39; ~ Dispatching input event.&amp;quot;, getInputChannelName());
#endif
                env-&amp;gt;CallVoidMethod(mReceiverObjGlobal,
                        gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj);
                if (env-&amp;gt;ExceptionCheck()) {
                    ALOGE(&amp;quot;Exception dispatching input event.&amp;quot;);
                    skipCallbacks = true;
                }
            } else {
                ALOGW(&amp;quot;channel &amp;#39;%s&amp;#39; ~ Failed to obtain event object.&amp;quot;, getInputChannelName());
                skipCallbacks = true;
            }
        }

        if (skipCallbacks) {
            mInputConsumer.sendFinishedSignal(seq, false);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里会回调到java层上的InputEventReceiver的dispatchInputEvent：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;// Called from native code.
    @SuppressWarnings(&amp;quot;unused&amp;quot;)
    private void dispatchInputEvent(int seq, InputEvent event) {
        mSeqMap.put(event.getSequenceNumber(), seq);
        onInputEvent(event);
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的onInputEvent(event)方法已经被WindowInputEventReceiver复写了:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Override
        public void onInputEvent(InputEvent event) {
            enqueueInputEvent(event, this, 0, true);
        }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里往下翻一点就知道这个队列做了什么事情:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;private void deliverInputEvent(QueuedInputEvent q) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &amp;quot;deliverInputEvent&amp;quot;);
        try {
            if (q.mEvent instanceof KeyEvent) {
                deliverKeyEvent(q);
            } else {
                final int source = q.mEvent.getSource();
                if ((source &amp;amp; InputDevice.SOURCE_CLASS_POINTER) != 0) {
                    deliverPointerEvent(q);
                } else if ((source &amp;amp; InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
                    deliverTrackballEvent(q);
                } else {
                    deliverGenericMotionEvent(q);
                }
            }
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里讲底层的inputEvent分成各种不同的类型去区别对待.&lt;/p&gt;

&lt;p&gt;这里就能看到View是如何接收事件的整个过程的&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;结论&lt;/h3&gt;

&lt;p&gt;1.androd的底层实现是通过socket和共享内存的方式，这种写法也可以采用在我们自己的多进程通信上使用，值得学习
2.底层所有的event其实都是一样的，都是inputEvent，上层会根据source再分成keyEvent,MotionEvent等，用于不同的用处
3.所有View的起点其实就是dispatchPointerEvent()，这个是分发事件的起点.&lt;/p&gt;

&lt;h3&gt;参考blog&lt;/h3&gt;
</content>
   </entry>
   
   <entry>
     <title>Android图形的知识</title>
     <link href="http://beiyuu.com/AndroidCanvas"/>
     <updated>2014-12-13T00:00:00+08:00</updated>
     <id>http://beiyuu.com/AndroidCanvas</id>
     <content type="html">&lt;h3&gt;关于自定义控件的基础知识&lt;/h3&gt;

&lt;p&gt;自定义控件的一个重点就是实现就是去重写他的绘制过程,也就是View.onDraw(Canvas canvas)方法。这个里面就是绘制图形的过程了，比如说一个Button，绘制按钮和按钮上的文字都是在它自己的onDraw方法中完成的。如果你想给ImageView加个蒙版，可以继承ImageView并且重写他的onDraw方法，调用完父类的onDraw之后，再自己Canvas来画一个黑色的半透明矩形，这样就可以对现有的控件进行加工了。
Canvas是什么呢？是画布，你绘制东西的时候就是绘到了这个画布上，给用户显示的东西也是这个画布上的东西。通常来说，当你调用到onDraw方法的时候对应的View已经确定了他的宽度和高度(关于View的measure和layout过程以后再详述)。那么在Canvas上，你画的范围就只有View对应的大小了。我们用代码来描述下&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    int verticalCenter    =  getHeight() / 2;
    int horizontalCenter  =  getWidth() / 2;
    int circleRadius      = 200;
    Paint paint = new Paint();
    paint.setAntiAlias(false);
    paint.setColor(Color.RED);
    canvas.drawCircle( horizontalCenter, verticalCenter-250, circleRadius, paint);

    paint.setAntiAlias(true);
    paint.setStyle(Paint.Style.STROKE);
    paint.setStrokeWidth(20);
    canvas.drawCircle( horizontalCenter, verticalCenter+250, circleRadius, paint);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个View的大小可以通过getHeight()和getWidth()来获得。我们准备画两个圆圈，半径都是200。我们主要用到的方法是drawCircle()方法，参数的意义分别是圆心的x，y坐标，半径和所使用的画笔Paint。&lt;/p&gt;

&lt;p&gt;Paint是什么？是画笔的意思，Canvas是画布，Paint是画笔，画笔控制了所画东西的颜色大小字体等等。在画第一个圆的时候，我们通过Paint.setAntiAlias方法设置抗锯齿属性为false，并设置颜色为红色。&lt;/p&gt;

&lt;p&gt;在画第二个圆的时候，我们打开了抗锯齿。将Paint的风格设为STROKE，也就是只画边框。然后设置边框宽度为20.&lt;/p&gt;

&lt;h3&gt;关于Canvas所涉及的到的类&lt;/h3&gt;

&lt;p&gt;android.graphics.* 包里面主要由以下一些类：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;Canvas/li&gt;
    &lt;li&gt;Bitmap及其相关的类&lt;/li&gt;
    &lt;li&gt;Xfermode及其子类&lt;/li&gt;
    &lt;li&gt;Paint及其相关类和内部类&lt;/li&gt;
    &lt;li&gt;Shader及其子类&lt;/li&gt;
    &lt;li&gt;Rect，Color，Point，Path等基础类&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Canvas.drawText绘制文字为什么会偏上？&lt;/h3&gt;

&lt;p&gt;如果你经常使用Canvas的draw***方法去绘制一些图像图形，你会知道绘制的时候坐标是从Canvas左上角开始计算的，如果想要把一个图像放到某个位置，直接drawBitmap传递图片左上角的坐标就行了.&lt;/p&gt;

&lt;p&gt;那drawText就不一样了，如果你传递进去字符串，会发现文字的位置和你指定的不一样。&lt;/p&gt;

&lt;p&gt;卧槽为啥。Android的文档也没有仔细说，打开源码一看，又跑到native代码里去执行了。经过我奋力地Google，终于把这个问题搞清楚了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android/android_drawtext.jpeg&quot; title=&quot;Optional title&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于一段文字来说，如果你想把他画到Canvas上，首先你要确定这段文字的范围，即宽度和高度，那么怎么去取这一段的高度呢，如果你在网上搜，会有很多种答案，具体应该用哪一种呢？这要看你到底需要什么样的尺寸了。&lt;/p&gt;

&lt;p&gt;Paint.getTextBounds: 当你通过这个方法来获取尺寸的时候，你可以得到能够包裹文字的最小矩形，就是图中红色边框的那部分，你可以得到一个Rect对象，包含这个最小尺寸的几个值。坑其实就在这里：这里的Rect对象坐标并不是以左上角为准的，而是相对于左边中间靠下位置的一个点，就是图中的黄色五角星。而这里水平的Baseline指的是字符串对齐的一条线（真正的含义可以需要更深入了解字体渲染的知识了）。既然这样，r.top就是一个负值了，r.bottom会是一个小一点的正值，r.left和r.right在图中画的都很清楚。通过r.width()和r.height()来获取尺寸。&lt;/p&gt;

&lt;p&gt;那么文字的偏移就好说了，比如说你要把文字画在Canvas的左上角，坐标是(0,0)，但是当你通过：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;canvas.drawText(“dangwen”,0,0,paint);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;来画文字的时候，发现只有文字的下半部分画出来了，因为你传递进去的参数应该是以Baseline为标准的，正确的方法是：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;canvas.drawText(“dangwen”,-r.left,-r.top,paint);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Paint.getFontMetricsInt(): 当你通过这里方法来获取尺寸的时候，你获取的只是一个垂直方向上的尺寸，这里的ascent代表的是字体的上部，descent代表的是字体的下部，这里需要注意的是这和上面获得的Rect的top和bottom不太一样，他们比比ascent和descent距离稍微小一些，这些具体的高度可能和不同的字体和渲染方式有关系，这里就不深入了 #我是不懂#。&lt;/p&gt;

&lt;p&gt;然后如果把文字写入TextView（图中蓝色部分）并且设置TextView的高度和宽度设为wrap_content，那么TextView的高度就正好是FontMetricsInt.top – FontMetricsInt.bottom, 那宽度呢？ Paint.measureText()。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;



</content>
   </entry>
   
   <entry>
     <title>android中如何高效的使用alpha属性</title>
     <link href="http://beiyuu.com/android-Alpha"/>
     <updated>2014-12-07T00:00:00+08:00</updated>
     <id>http://beiyuu.com/android-Alpha</id>
     <content type="html">&lt;h2&gt;#&lt;/h2&gt;

&lt;p&gt;Alpha是图形界面开发中常用的特效，通常我们会使用以下代码来实现Alpha特效：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;view.setAlpha(0.5f);
    View.ALPHA.set(view, 0.5f);
    ObjectAnimator.ofFloat(view, &amp;quot;alpha&amp;quot;, 0.5f).start();
    view.animate().alpha(0.5f).start();
    view.setAnimation(new AlphaAnimation(1.0f, 0.5f));&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其效果都等同于：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;canvas.saveLayer(l, r, t, b, 127, Canvas.CLIP_TO_LAYER_SAVE_FLAG);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所以常见的alpha特效是通过将图像绘制到offscreen buffer中然后显示出来，这样的操作是非常消耗资源的，甚至可能导致性能问题，在开发过程中我们可以通过其他方式避免创建offsreen buffer。&lt;/p&gt;

&lt;h3&gt;TextView&lt;/h3&gt;

&lt;p&gt;对于TextView我们通常需要文字透明效果，而不是View本身透明，所以，直接设置带有alpha值的TextColor是比较高效的方式。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;// Not this
    textView.setAlpha(alpha);
    
    // 以下方式可以避免创建 offscreen buffer
    int newTextColor = (int) (0xFF * alpha) &amp;lt;&amp;lt; 24 | baseTextColor &amp;amp; 0xFFFFFF;
    textView.setTextColor(newTextColor);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;ImageView&lt;/h3&gt;

&lt;p&gt;同样的对于只具有src image的ImageView，直接调用setImageAlpha()方法更为合理。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;// Not this, setAlpha方法由View继承而来，性能不佳
    imageView.setAlpha(0.5f);

    // 使用以下方式时，ImageView会在绘制图片时单独为图片指定Alpha
    // 可以避免创建 offScreenBuffer
    imageView.setImageAlpha((int) alpha * 255);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;CustomView&lt;/h3&gt;

&lt;p&gt;类似的，自定义控件时，应该直接去设置paint的alpha。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;// Not this
    customView.setAlpha(alpha);

    // But this
    paint.setAlpha((int) alpha * 255);
    canvas.draw*(..., paint);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同时Android提供了hasOverlappingRendering()接口，通过重写该接口可以告知系统当前View是否存在内容重叠的情况，帮助系统优化绘制流程，原理是这样的：对于有重叠内容的View，系统简单粗暴的使用 offscreen buffer来协助处理。当告知系统该View无重叠内容时，系统会分别使用合适的alpha值绘制每一层。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;/**
 * Returns whether this View has content which overlaps. This function, intended to be
 * overridden by specific View types, is an optimization when alpha is set on a view. If
 * rendering overlaps in a view with alpha &amp;lt; 1, that view is drawn to an offscreen buffer
 * and then composited it into place, which can be expensive. If the view has no overlapping
 * rendering, the view can draw each primitive with the appropriate alpha value directly.
 * An example of overlapping rendering is a TextView with a background image, such as a
 * Button. An example of non-overlapping rendering is a TextView with no background, or
 * an ImageView with only the foreground image. The default implementation returns true;
 * subclasses should override if they have cases which can be optimized.
 *
 * @return true if the content in this view might overlap, false otherwise.
 */
public boolean hasOverlappingRendering() {
    return true;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后引用Chet Haase的一句话作为总结&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;“You know what your view is doing, so do the right thing for your situation.”&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;http://blog.csdn.net/guolin_blog/article/details/16330267&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>android的View绘制</title>
     <link href="http://beiyuu.com/view"/>
     <updated>2014-11-28T00:00:00+08:00</updated>
     <id>http://beiyuu.com/view</id>
     <content type="html">&lt;h3&gt;遇到的问题&lt;/h3&gt;

&lt;p&gt;https://developer.android.com/tools/sdk/ndk/index.html#Installing&lt;/p&gt;

&lt;h3&gt;关于View被绘制到屏幕的过程&lt;/h3&gt;

&lt;h2&gt;onMeasure()&lt;/h2&gt;

&lt;p&gt;measure是测量的意思，那么onMeasure()方法顾名思义就是用于测量视图的大小的。View系统的绘制流程会从ViewRoot的performTraversals()方法中开始，在其内部调用View的measure()方法。measure()方法接收两个参数，widthMeasureSpec和heightMeasureSpec，这两个值分别用于确定视图的宽度和高度的规格和大小。&lt;/p&gt;

&lt;p&gt;MeasureSpec的值由specSize和specMode共同组成的，其中specSize记录的是大小，specMode记录的是规格。specMode一共有三种类型，如下所示:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;EXACTLY
表示父视图希望子视图的大小应该是由specSize的值来决定的，系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AT_MOST
表示子视图最多只能是specSize中指定的大小，开发人员应该尽可能小得去设置这个视图，并且保证不会超过specSize。系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;UNSPECIFIED
表示开发人员可以将视图按照自己的意愿设置成任意的大小，没有任何限制。这种情况比较少见，不太会用到。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;那么你可能会有疑问了，widthMeasureSpec和heightMeasureSpec这两个值又是从哪里得到的呢？通常情况下，这两个值都是由父视图经过计算后传递给子视图的，说明父视图会在一定程度上决定子视图的大小。但是最外层的根视图，它的widthMeasureSpec和heightMeasureSpec又是从哪里得到的呢？这就需要去分析ViewRoot中的源码了，观察performTraversals()方法可以发现如下代码：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width); 
    childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，这里调用了getRootMeasureSpec()方法去获取widthMeasureSpec和heightMeasureSpec的值，注意方法中传入的参数，其中lp.width和lp.height在创建ViewGroup实例的时候就被赋值了，它们都等于MATCH_PARENT。然后看下getRootMeasureSpec()方法中的代码，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;private int getRootMeasureSpec(int windowSize, int rootDimension) {
    int measureSpec;
    switch (rootDimension) {
    case ViewGroup.LayoutParams.MATCH_PARENT:
        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
        break;
    case ViewGroup.LayoutParams.WRAP_CONTENT:
        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
        break;
    default:
        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
        break;
    }
    return measureSpec;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，这里使用了MeasureSpec.makeMeasureSpec()方法来组装一个MeasureSpec，当rootDimension参数等于MATCH_PARENT的时候，MeasureSpec的specMode就等于EXACTLY，当rootDimension等于WRAP_CONTENT的时候，MeasureSpec的specMode就等于AT_MOST。并且MATCH_PARENT和WRAP_CONTENT时的specSize都是等于windowSize的，也就意味着根视图总是会充满全屏的。&lt;/p&gt;

&lt;p&gt;介绍了这么多MeasureSpec相关的内容，接下来我们看下View的measure()方法里面的代码吧，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
    if ((mPrivateFlags &amp;amp; FORCE_LAYOUT) == FORCE_LAYOUT ||
            widthMeasureSpec != mOldWidthMeasureSpec ||
            heightMeasureSpec != mOldHeightMeasureSpec) {
        mPrivateFlags &amp;amp;= ~MEASURED_DIMENSION_SET;
        if (ViewDebug.TRACE_HIERARCHY) {
            ViewDebug.trace(this, ViewDebug.HierarchyTraceType.ON_MEASURE);
        }
        onMeasure(widthMeasureSpec, heightMeasureSpec);
        if ((mPrivateFlags &amp;amp; MEASURED_DIMENSION_SET) != MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(&amp;quot;onMeasure() did not set the&amp;quot;
                    + &amp;quot; measured dimension by calling&amp;quot;
                    + &amp;quot; setMeasuredDimension()&amp;quot;);
        }
        mPrivateFlags |= LAYOUT_REQUIRED;
    }
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意观察，measure()这个方法是final的，因此我们无法在子类中去重写这个方法，说明Android是不允许我们改变View的measure框架的。然后在第9行调用了onMeasure()方法，这里才是真正去测量并设置View大小的地方，默认会调用getDefaultSize()方法来获取视图的大小，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public static int getDefaultSize(int size, int measureSpec) {
    int result = size;
    int specMode = MeasureSpec.getMode(measureSpec);
    int specSize = MeasureSpec.getSize(measureSpec);
    switch (specMode) {
    case MeasureSpec.UNSPECIFIED:
        result = size;
        break;
    case MeasureSpec.AT_MOST:
    case MeasureSpec.EXACTLY:
        result = specSize;
        break;
    }
    return result;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里传入的measureSpec是一直从measure()方法中传递过来的。然后调用MeasureSpec.getMode()方法可以解析出specMode，调用MeasureSpec.getSize()方法可以解析出specSize。接下来进行判断，如果specMode等于AT_MOST或EXACTLY就返回specSize，这也是系统默认的行为。之后会在onMeasure()方法中调用setMeasuredDimension()方法来设定测量出的大小，这样一次measure过程就结束了。&lt;/p&gt;

&lt;p&gt;当然，一个界面的展示可能会涉及到很多次的measure，因为一个布局中一般都会包含多个子视图，每个视图都需要经历一次measure过程。ViewGroup中定义了一个measureChildren()方法来去测量子视图的大小，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
    final int size = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i &amp;lt; size; ++i) {
        final View child = children[i];
        if ((child.mViewFlags &amp;amp; VISIBILITY_MASK) != GONE) {
            measureChild(child, widthMeasureSpec, heightMeasureSpec);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，在第4行和第6行分别调用了getChildMeasureSpec()方法来去计算子视图的MeasureSpec，计算的依据就是布局文件中定义的MATCH_PARENT、WRAP_CONTENT等值，这个方法的内部细节就不再贴出。然后在第8行调用子视图的measure()方法，并把计算出的MeasureSpec传递进去，之后的流程就和前面所介绍的一样了。&lt;/p&gt;

&lt;p&gt;当然，onMeasure()方法是可以重写的，也就是说，如果你不想使用系统默认的测量方式，可以按照自己的意愿进行定制，比如：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class MyView extends View {

    ......
    
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(200, 200);
    }

    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样的话就把View默认的测量流程覆盖掉了，不管在布局文件中定义MyView这个视图的大小是多少，最终在界面上显示的大小都将会是200*200。&lt;/p&gt;

&lt;p&gt;需要注意的是，在setMeasuredDimension()方法调用之后，我们才能使用getMeasuredWidth()和getMeasuredHeight()来获取视图测量出的宽高，以此之前调用这两个方法得到的值都会是0。&lt;/p&gt;

&lt;p&gt;由此可见，视图大小的控制是由父视图、布局文件、以及视图本身共同完成的，父视图会提供给子视图参考的大小，而开发人员可以在XML文件中指定视图的大小，然后视图本身会对最终的大小进行拍板。&lt;/p&gt;

&lt;h2&gt;onLayout()&lt;/h2&gt;

&lt;p&gt;measure过程结束后，视图的大小就已经测量好了，接下来就是layout的过程了。正如其名字所描述的一样，这个方法是用于给视图进行布局的，也就是确定视图的位置。ViewRoot的performTraversals()方法会在measure结束后继续执行，并调用View的layout()方法来执行此过程，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;host.layout(0, 0, host.mMeasuredWidth, host.mMeasuredHeight);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;layout()方法接收四个参数，分别代表着左、上、右、下的坐标，当然这个坐标是相对于当前视图的父视图而言的。可以看到，这里还把刚才测量出的宽度和高度传到了layout()方法中。那么我们来看下layout()方法中的代码是什么样的吧，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public void layout(int l, int t, int r, int b) {
    int oldL = mLeft;
    int oldT = mTop;
    int oldB = mBottom;
    int oldR = mRight;
    boolean changed = setFrame(l, t, r, b);
    if (changed || (mPrivateFlags &amp;amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) {
        if (ViewDebug.TRACE_HIERARCHY) {
            ViewDebug.trace(this, ViewDebug.HierarchyTraceType.ON_LAYOUT);
        }
        onLayout(changed, l, t, r, b);
        mPrivateFlags &amp;amp;= ~LAYOUT_REQUIRED;
        if (mOnLayoutChangeListeners != null) {
            ArrayList&amp;lt;OnLayoutChangeListener&amp;gt; listenersCopy =
                    (ArrayList&amp;lt;OnLayoutChangeListener&amp;gt;) mOnLayoutChangeListeners.clone();
            int numListeners = listenersCopy.size();
            for (int i = 0; i &amp;lt; numListeners; ++i) {
                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);
            }
        }
    }
    mPrivateFlags &amp;amp;= ~FORCE_LAYOUT;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在layout()方法中，首先会调用setFrame()方法来判断视图的大小是否发生过变化，以确定有没有必要对当前的视图进行重绘，同时还会在这里把传递过来的四个参数分别赋值给mLeft、mTop、mRight和mBottom这几个变量。接下来会在第11行调用onLayout()方法，正如onMeasure()方法中的默认行为一样，也许你已经迫不及待地想知道onLayout()方法中的默认行为是什么样的了。进入onLayout()方法，咦？怎么这是个空方法，一行代码都没有？！&lt;/p&gt;

&lt;p&gt;没错，View中的onLayout()方法就是一个空方法，因为onLayout()过程是为了确定视图在布局中所在的位置，而这个操作应该是由布局来完成的，即父视图决定子视图的显示位置。既然如此，我们来看下ViewGroup中的onLayout()方法是怎么写的吧，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Override
    protected abstract void onLayout(boolean changed, int l, int t, int r, int b);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，ViewGroup中的onLayout()方法竟然是一个抽象方法，这就意味着所有ViewGroup的子类都必须重写这个方法。没错，像LinearLayout、RelativeLayout等布局，都是重写了这个方法，然后在内部按照各自的规则对子视图进行布局的。由于LinearLayout和RelativeLayout的布局规则都比较复杂，就不单独拿出来进行分析了，这里我们尝试自定义一个布局，借此来更深刻地理解onLayout()的过程。&lt;/p&gt;

&lt;p&gt;自定义的这个布局目标很简单，只要能够包含一个子视图，并且让子视图正常显示出来就可以了。那么就给这个布局起名叫做SimpleLayout吧，代码如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class SimpleLayout extends ViewGroup {

    public SimpleLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        if (getChildCount() &amp;gt; 0) {
            View childView = getChildAt(0);
            measureChild(childView, widthMeasureSpec, heightMeasureSpec);
        }
    }

    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        if (getChildCount() &amp;gt; 0) {
            View childView = getChildAt(0);
            childView.layout(0, 0, childView.getMeasuredWidth(), childView.getMeasuredHeight());
        }
    }

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;代码非常的简单，我们来看下具体的逻辑吧。你已经知道，onMeasure()方法会在onLayout()方法之前调用，因此这里在onMeasure()方法中判断SimpleLayout中是否有包含一个子视图，如果有的话就调用measureChild()方法来测量出子视图的大小。&lt;/p&gt;

&lt;p&gt;接着在onLayout()方法中同样判断SimpleLayout是否有包含一个子视图，然后调用这个子视图的layout()方法来确定它在SimpleLayout布局中的位置，这里传入的四个参数依次是0、0、childView.getMeasuredWidth()和childView.getMeasuredHeight()，分别代表着子视图在SimpleLayout中左上右下四个点的坐标。其中，调用childView.getMeasuredWidth()和childView.getMeasuredHeight()方法得到的值就是在onMeasure()方法中测量出的宽和高。&lt;/p&gt;

&lt;p&gt;这样就已经把SimpleLayout这个布局定义好了，下面就是在XML文件中使用它了，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&amp;lt;com.example.viewtest.SimpleLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot; &amp;gt;
    
    &amp;lt;ImageView 
        android:layout_width=&amp;quot;wrap_content&amp;quot;
        android:layout_height=&amp;quot;wrap_content&amp;quot;
        android:src=&amp;quot;@drawable/ic_launcher&amp;quot;
        /&amp;gt;
    
    &amp;lt;/com.example.viewtest.SimpleLayout&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在onLayout()过程结束后，我们就可以调用getWidth()方法和getHeight()方法来获取视图的宽高了。说到这里，我相信很多朋友长久以来都会有一个疑问，getWidth()方法和getMeasureWidth()方法到底有什么区别呢？它们的值好像永远都是相同的。其实它们的值之所以会相同基本都是因为布局设计者的编码习惯非常好，实际上它们之间的差别还是挺大的。&lt;/p&gt;

&lt;p&gt;首先getMeasureWidth()方法在measure()过程结束后就可以获取到了，而getWidth()方法要在layout()过程结束后才能获取到。另外，getMeasureWidth()方法中的值是通过setMeasuredDimension()方法来进行设置的，而getWidth()方法中的值则是通过视图右边的坐标减去左边的坐标计算出来的。&lt;/p&gt;

&lt;p&gt;观察SimpleLayout中onLayout()方法的代码，这里给子视图的layout()方法传入的四个参数分别是0、0、childView.getMeasuredWidth()和childView.getMeasuredHeight()，因此getWidth()方法得到的值就是childView.getMeasuredWidth() - 0 = childView.getMeasuredWidth() ，所以此时getWidth()方法和getMeasuredWidth() 得到的值就是相同的，但如果你将onLayout()方法中的代码进行如下修改：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
    if (getChildCount() &amp;gt; 0) {
        View childView = getChildAt(0);
        childView.layout(0, 0, 200, 200);
    }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样getWidth()方法得到的值就是200 - 0 = 200，不会再和getMeasuredWidth()的值相同了。当然这种做法充分不尊重measure()过程计算出的结果，通常情况下是不推荐这么写的。getHeight()与getMeasureHeight()方法之间的关系同上，就不再重复分析了。&lt;/p&gt;

&lt;h2&gt;onDraw()&lt;/h2&gt;

&lt;p&gt;measure和layout的过程都结束后，接下来就进入到draw的过程了。同样，根据名字你就能够判断出，在这里才真正地开始对视图进行绘制。ViewRoot中的代码会继续执行并创建出一个Canvas对象，然后调用View的draw()方法来执行具体的绘制工作。draw()方法内部的绘制过程总共可以分为六步，其中第二步和第五步在一般情况下很少用到，因此这里我们只分析简化后的绘制过程。代码如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public void draw(Canvas canvas) {
    if (ViewDebug.TRACE_HIERARCHY) {
        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
    }
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags &amp;amp; DIRTY_MASK) == DIRTY_OPAQUE &amp;amp;&amp;amp;
            (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags &amp;amp; ~DIRTY_MASK) | DRAWN;
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        final Drawable background = mBGDrawable;
        if (background != null) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            if (mBackgroundSizeChanged) {
                background.setBounds(0, 0,  mRight - mLeft, mBottom - mTop);
                mBackgroundSizeChanged = false;
            }
            if ((scrollX | scrollY) == 0) {
                background.draw(canvas);
            } else {
                canvas.translate(scrollX, scrollY);
                background.draw(canvas);
                canvas.translate(-scrollX, -scrollY);
            }
        }
    }
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags &amp;amp; FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags &amp;amp; FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges &amp;amp;&amp;amp; !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque) onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        // Step 6, draw decorations (scrollbars)
        onDrawScrollBars(canvas);
        // we&amp;#39;re done...
        return;
    }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，第一步是从第9行代码开始的，这一步的作用是对视图的背景进行绘制。这里会先得到一个mBGDrawable对象，然后根据layout过程确定的视图位置来设置背景的绘制区域，之后再调用Drawable的draw()方法来完成背景的绘制工作。那么这个mBGDrawable对象是从哪里来的呢？其实就是在XML中通过android:background属性设置的图片或颜色。当然你也可以在代码中通过setBackgroundColor()、setBackgroundResource()等方法进行赋值。&lt;/p&gt;

&lt;p&gt;接下来的第三步是在第34行执行的，这一步的作用是对视图的内容进行绘制。可以看到，这里去调用了一下onDraw()方法，那么onDraw()方法里又写了什么代码呢？进去一看你会发现，原来又是个空方法啊。其实也可以理解，因为每个视图的内容部分肯定都是各不相同的，这部分的功能交给子类来去实现也是理所当然的。&lt;/p&gt;

&lt;p&gt;第三步完成之后紧接着会执行第四步，这一步的作用是对当前视图的所有子视图进行绘制。但如果当前的视图没有子视图，那么也就不需要进行绘制了。因此你会发现View中的dispatchDraw()方法又是一个空方法，而ViewGroup的dispatchDraw()方法中就会有具体的绘制代码。&lt;/p&gt;

&lt;p&gt;以上都执行完后就会进入到第六步，也是最后一步，这一步的作用是对视图的滚动条进行绘制。那么你可能会奇怪，当前的视图又不一定是ListView或者ScrollView，为什么要绘制滚动条呢？其实不管是Button也好，TextView也好，任何一个视图都是有滚动条的，只是一般情况下我们都没有让它显示出来而已。绘制滚动条的代码逻辑也比较复杂，这里就不再贴出来了，因为我们的重点是第三步过程&lt;/p&gt;

&lt;p&gt;通过以上流程分析，相信大家已经知道，View是不会帮我们绘制内容部分的，因此需要每个视图根据想要展示的内容来自行绘制。如果你去观察TextView、ImageView等类的源码，你会发现它们都有重写onDraw()这个方法，并且在里面执行了相当不少的绘制逻辑。绘制的方式主要是借助Canvas这个类，它会作为参数传入到onDraw()方法中，供给每个视图使用。Canvas这个类的用法非常丰富，基本可以把它当成一块画布，在上面绘制任意的东西，那么我们就来尝试一下吧。&lt;/p&gt;

&lt;p&gt;这里简单起见，我只是创建一个非常简单的视图，并且用Canvas随便绘制了一点东西，代码如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class MyView extends View {

    private Paint mPaint;

    public MyView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        mPaint.setColor(Color.YELLOW);
        canvas.drawRect(0, 0, getWidth(), getHeight(), mPaint);
        mPaint.setColor(Color.BLUE);
        mPaint.setTextSize(20);
        String text = &amp;quot;Hello View&amp;quot;;
        canvas.drawText(text, 0, getHeight() / 2, mPaint);
    }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，我们创建了一个自定义的MyView继承自View，并在MyView的构造函数中创建了一个Paint对象。Paint就像是一个画笔一样，配合着Canvas就可以进行绘制了。这里我们的绘制逻辑比较简单，在onDraw()方法中先是把画笔设置成黄色，然后调用Canvas的drawRect()方法绘制一个矩形。然后在把画笔设置成蓝色，并调整了一下文字的大小，然后调用drawText()方法绘制了一段文字。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;http://blog.csdn.net/guolin_blog/article/details/16330267&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>android的NDK调试常见问题</title>
     <link href="http://beiyuu.com/ndk"/>
     <updated>2014-11-17T00:00:00+08:00</updated>
     <id>http://beiyuu.com/ndk</id>
     <content type="html">&lt;h3&gt;遇到的问题&lt;/h3&gt;

&lt;p&gt;https://developer.android.com/tools/sdk/ndk/index.html#Installing&lt;/p&gt;

&lt;h3&gt;用GDB进行so调试&lt;/h3&gt;

&lt;h2&gt;编译&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;要有没有strip的so
strip命令位置: toolchains/arm-linux-androideabi-4.6/prebuilt/linux-x86_64/arm-linux-androideabi/bin/strip 注意strip前要保留原来的so文件,以后调试时需要使用&lt;/li&gt;
&lt;li&gt;其他: 用nm命令 可以列出so内的符号,可以用于查看so是否有符号,如 nm xx.so&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;GDB 调试so&lt;/h2&gt;

&lt;p&gt;需要的文件:
gdbserver 位置:android-ndk-r8b/prebuilt/android-arm/gdbserver/gdbserver
gdb 位置:android-ndk-r8b/toolchains/arm-linux-androideabi-4.6/prebuilt/linux-x86/bin/arm-linux-androideabi-gdb
步骤:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;apk 打开调试开关, AndroidManifest.xml 中, application节点 加入 android:debuggable=&quot;true&quot;,&lt;/li&gt;
&lt;li&gt;如果是root的机器,apk没有打开调试开关也可以进行调试,如果是已经root的机器,把gdbserver放到系统(手机)的目录下(可以随意放置,一般放到system/bin目录下方便输入命令)&lt;/li&gt;
&lt;li&gt;如果是没有root的机器,需要把gdbserver打到apk的包里(放到lib目录下),这样安装apk的的时候会把gdbserver拷贝到/data/data/app名称/lib/gdbserver&lt;/li&gt;
&lt;li&gt;启动apk,可以直接启动&lt;/li&gt;
&lt;li&gt;用 adb shell 进行控制台,用ps命令查看app的进程id&lt;/li&gt;
&lt;li&gt;如果是root机器,可以su后,直接用gdbserver attach ,命令行是 gdbserver :端口号 --attach pid 如 : su gdbserver :2345 --attach pid&lt;/li&gt;
&lt;li&gt;如果是未root机器,只能用以下方式 run-as app名称 lib/gdbserver :端口号 --attach pid&lt;/li&gt;
&lt;li&gt;在pc上运行adb forward tcp:端口号(指PC上的端口) tcp:端口号(手机上的端口) 建立端口映射&lt;/li&gt;
&lt;li&gt;把/system/bin/app_process /system/bin/linker, /system/lib/libc.so 从手机上拷贝出来(可以用adb pull 命令),其他so文件也拷贝出来也行,我们假定拷贝的目录为$lib&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行arm-linux-androideabi-gdb ,输入以下命令序列
file $lib/app_process $lib目录中有从手机拷贝出来的app_process,linker和libc.so这些文件 ,如我放到了/home/qrf/android_ndk_debug/mydev目录下&lt;/p&gt;

&lt;p&gt;set solib-absolute-prefix $nostriplib_dir $nostriplib_dir是存放了没有strip的so的目录,如 set solib-absolute-prefix /home/qrf/code/cmso&lt;/p&gt;

&lt;p&gt;set solib-search-path $lib:$nostriplib_dir 如set solib-search-path /home/qrf/android_ndk_debug/mydev:/home/qrf/code/cmso&lt;/p&gt;

&lt;p&gt;target remote :端口号 连上gdbserver&lt;/p&gt;

&lt;p&gt;dir source 指定源码路径
后面就是gdb调试的问题了,进入gdb调试界面可以用ctrl x + a 来切换到&lt;strong&gt;&lt;em&gt;文本模式&lt;/em&gt;&lt;/strong&gt;(可以查看源码), 如果要配合ddd前端, 用apt-get install ddd ,然后 用ddd --debugger arm-linux-androideabi-gdb 使用,但是ddd有时会不太灵光,还是直接使用gdb比较方便&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;附一些常用的gdb命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;backtrace/bt    //列出当前线程堆栈

thread apply all bt //列出所有线程调用堆栈

thread 线程号//切换线程上下文

ctrl x+a //切换到源码浏览窗口 ，再按ctrl x+a 切换回去

ctrl c //中断当前运行

c/continue //继续运行

info sharedlibrary //列出so加载列表

info threads //列出线程列表

info locals //列出当前堆栈上的局部变量

info breakpoints //列出断点

print 变量名 //列出变量内容 

print 变量名= //修改变量名的值

b/break 源码文件名:行号 //下断点

d/delete 断点id //删除断点

f/frame 栈帧序号 //切换到指定的栈帧 如 f 0 顶层

s/step //下一步，有函数调用会进入

n/next //下一步，有函数调用不会进入

fin/finish //返回到上层函数调用

disable 断点id  //禁用断点

enable 断点id  //启用断点

disassemble/disas //查看汇编代码
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>git和SVN配合</title>
     <link href="http://beiyuu.com/git-svn"/>
     <updated>2014-11-16T00:00:00+08:00</updated>
     <id>http://beiyuu.com/git-svn</id>
     <content type="html">&lt;h3&gt;使用Git有什么方便的？&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;把大修改点拆小提交记录。&lt;/li&gt;
&lt;li&gt;随时更新服务器代码到本地，不影响当前工作环境。&lt;/li&gt;
&lt;li&gt;连不上服务器时，也能正常工作。&lt;/li&gt;
&lt;li&gt;数据分布式存放，数据丢失的可能性最小。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;推荐读物 Pro Git&lt;/h3&gt;

&lt;h3&gt;常用命令&lt;/h3&gt;

&lt;table class=&quot;wiki&quot;&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;说明&lt;/strong&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git svn clone -s http://svn.repo.url&lt;/td&gt;&lt;td&gt;从远程SVN服务器下拉所有代码变化到本地(SVN目录必须符合标准，有trunk, tags, branches，否则把-s选项去掉)
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git svn fetch&lt;/td&gt;&lt;td&gt;从远程SVN服务器下拉代码变化到本地Git服务端
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git svn dcommit&lt;/td&gt;&lt;td&gt;把本地Git服务端的代码变化，同步提交到远程SVN服务器
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git branch&lt;/td&gt;&lt;td&gt;查看本地分支列表
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git branch -a&lt;/td&gt;&lt;td&gt;查看所有分支列表
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git branch -d branchName&lt;/td&gt;&lt;td&gt;删除本地分支
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git branch -D branchName&lt;/td&gt;&lt;td&gt;强制删除本地分支
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git checkout -b locBranchName remotes/branchName&lt;/td&gt;&lt;td&gt;从远程(其实就是本机的git服务端)分支创建一个本地分支，并将工作目录切换到这个本地分支
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git checkout locBranchName&lt;/td&gt;&lt;td&gt;把工作目录切换到一个已存在的本地分支
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git checkout *&lt;/td&gt;&lt;td&gt;把工作目录内没有提交的所有修改恢复原样，相当于svn的revert操作
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git clean -n&lt;/td&gt;&lt;td&gt;查看有什么多余的文件可以清理的
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git clean -f&lt;/td&gt;&lt;td&gt;清理多余的文件
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git gui&lt;/td&gt;&lt;td&gt;git提供的一个图形界面工具，常用来提交代码
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;gitk&lt;/td&gt;&lt;td&gt;git的一个图形界面工具，常用来查看日志及变化
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git rebase remotes/branchName&lt;/td&gt;&lt;td&gt;把远程(其实就是本机的git服务端)分支的最新变更合并到本地分支
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git cherry-pick {SHA1-ID}&lt;/td&gt;&lt;td&gt;把指定SHA1 ID的修改点合并到当前本地分支
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git diff&lt;/td&gt;&lt;td&gt;查看变化
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git difftool -t meld -y&lt;/td&gt;&lt;td&gt;用meld查看变化
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git mergetool -t meld -y&lt;/td&gt;&lt;td&gt;用meld合并解决冲突代码
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;



</content>
   </entry>
   
   <entry>
     <title>关于java String的匹配问题</title>
     <link href="http://beiyuu.com/sqlite-efficiency"/>
     <updated>2014-11-15T00:00:00+08:00</updated>
     <id>http://beiyuu.com/sqlite-efficiency</id>
     <content type="html">&lt;h3&gt;遇到的问题&lt;/h3&gt;

&lt;p&gt;这次在调程序性能的时候发现有多处的String匹配，加上各种云端开关，想到之前字符串匹配用到的KMP算法，所以打算采用KMP算法：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class KMP {
    public int kmpMatch(String s, String p){
        int[] next = new int[s.length()];
        int i,j;
        i=0;
        j=0;
        getNext(p,next);
        while(i&amp;lt;s.length()){
            if(j==-1||s.charAt(i)==p.charAt(j)){
                i++;
                j++;
            }else{
                j=next[j]; // eliminate Trace Back
            }
            if(j==p.length()){
                return i-p.length();
            }
        }
        return -1;
    }

    private void getNext(String p, int[] next){
        int j,k;
        next[0]=-1;
        j=0;
        k=-1;
        while(j&amp;lt;p.length()-1){
            if(k==-1 || p.charAt(j)==p.charAt(k)){
                j++;
                k++;
                next[j]=k;
            }else{
                k=next[k];
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但是发现，性能竟然降下去了。&lt;/p&gt;

&lt;h3&gt;关于java的字符串匹配的问题&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;我们之前的代码采用的jdk的**contains api**
源码如下：
![Alt text]( /images/android/2014_java_indexof.png &quot;Optional title&quot;)

发现牛逼的jre源码竟然采用了最朴实的算法,我们知道KMP的时间复杂度是非常好的为o(n)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为何源码采用朴素算法,不采用KMP？在stackOverFlow上找到了一些蛛丝马迹:
    KMP算法具有更好的性能，但实际上需要一点点的前面计算（产生的偏移量表）。IT也需要一个初始的内存分配，这也可能影响性能。
    而且使用String的&lt;strong&gt;charAt &lt;/strong&gt;会对性能的造成损耗，这个需要注意！！！&lt;/p&gt;

&lt;p&gt;此外，测试了了String的几个查找subString的API：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;string.contains()&lt;/li&gt;
&lt;li&gt;string.indexOf()&lt;/li&gt;
&lt;li&gt;regular expression. it is something like string.matches(&quot;ja&quot;))&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;性能 string.indexOf() &gt; string.contains() &gt; string.matches(&quot;ja&quot;))&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>关于java String的匹配问题</title>
     <link href="http://beiyuu.com/java-String"/>
     <updated>2014-11-14T00:00:00+08:00</updated>
     <id>http://beiyuu.com/java-String</id>
     <content type="html">&lt;h3&gt;遇到的问题&lt;/h3&gt;

&lt;p&gt;这次在调程序性能的时候发现有多处的String匹配，加上各种云端开关，想到之前字符串匹配用到的KMP算法，所以打算采用KMP算法：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class KMP {
    public int kmpMatch(String s, String p){
        int[] next = new int[s.length()];
        int i,j;
        i=0;
        j=0;
        getNext(p,next);
        while(i&amp;lt;s.length()){
            if(j==-1||s.charAt(i)==p.charAt(j)){
                i++;
                j++;
            }else{
                j=next[j]; // eliminate Trace Back
            }
            if(j==p.length()){
                return i-p.length();
            }
        }
        return -1;
    }

    private void getNext(String p, int[] next){
        int j,k;
        next[0]=-1;
        j=0;
        k=-1;
        while(j&amp;lt;p.length()-1){
            if(k==-1 || p.charAt(j)==p.charAt(k)){
                j++;
                k++;
                next[j]=k;
            }else{
                k=next[k];
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但是发现，性能竟然降下去了。&lt;/p&gt;

&lt;h3&gt;关于java的字符串匹配的问题&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;我们之前的代码采用的jdk的**contains api**
源码如下：
![Alt text]( /images/android/2014_java_indexof.png &quot;Optional title&quot;)

发现牛逼的jre源码竟然采用了最朴实的算法,我们知道KMP的时间复杂度是非常好的为o(n)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为何源码采用朴素算法,不采用KMP？在stackOverFlow上找到了一些蛛丝马迹:
    KMP算法具有更好的性能，但实际上需要一点点的前面计算（产生的偏移量表）。IT也需要一个初始的内存分配，这也可能影响性能。
    而且使用String的&lt;strong&gt;charAt &lt;/strong&gt;会对性能的造成损耗，这个需要注意！！！&lt;/p&gt;

&lt;p&gt;此外，测试了了String的几个查找subString的API：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;string.contains()&lt;/li&gt;
&lt;li&gt;string.indexOf()&lt;/li&gt;
&lt;li&gt;regular expression. it is something like string.matches(&quot;ja&quot;))&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;性能 string.indexOf() &gt; string.contains() &gt; string.matches(&quot;ja&quot;))&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>ant打包策略</title>
     <link href="http://beiyuu.com/andoird-ant"/>
     <updated>2014-10-17T00:00:00+08:00</updated>
     <id>http://beiyuu.com/andoird-ant</id>
     <content type="html">&lt;h3&gt;操作流程&lt;/h3&gt;

&lt;p&gt;1.准备必要工具。
    - ​python2.X(注意，不能用3.X版本)
    - apache-ant-1.8.4(注意，一定要此版本)
    - android sdk
2.把python路径(如：c:\Python25)，ant路径(如d:\apache-ant-1.8.4\bin),sdk工具路径(如d:\android-sdk\build-tools\18.1.1)加入PATH环境变量。
3.在CleanMaster工程所在路径，用python调用build/changebuildXXX/before.py脚本修改工程环境。(如果你想打国内版的包，就是changebuild0，如果想打国际版的包，就是changebuil1) 参看：如何构造一个指定包版本的工程代码环境
4.修改local.properties中配置的SDK路径。
5.修改proguard.cfg中-libraryjars开头的三行配置路径。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;-libraryjars &amp;#39;D:\Program Files\Java\jre6\lib\rt.jar&amp;#39;
-libraryjars &amp;#39;D:\install\Android\android-sdk\platforms\android-17\android.jar&amp;#39;
-libraryjars &amp;#39;D:\install\Android\android-sdk\platforms\android-17\data\layoutlib.jar&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;6.修改custom_rules_commons.xml中配置的python路径。
7.在CleanMaster工程所在路径，执行ant clean。
8.在CleanMaster工程所在路径，执行ant cmrelease。构建成功后，安装包在bin/channel路径下。&lt;/p&gt;

&lt;h3&gt;FAQ&lt;/h3&gt;

&lt;p&gt;1.如果出现下述报错，就是lint检查失败了，没有生成结果文件。
&lt;img src=&quot;/images/android/android_ant.jpg&quot; title=&quot;Optional title&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
 
</feed>
