<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>Yangming.com</title>
   <link href="http://yangm90.github.io/Blog//atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://yangm90.github.io/Blog/" rel="alternate" type="text/html" />
   <updated>2015-02-06T15:55:53+08:00</updated>
   <id>http://yangm90.github.io/Blog/</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>简历</title>
     <link href="http://beiyuu.com/ymResume"/>
     <updated>2015-01-28T00:00:00+08:00</updated>
     <id>http://beiyuu.com/ymResume</id>
     <content type="html">&lt;hr /&gt;

&lt;h1&gt;个人信息&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;杨明/男/1990&lt;/li&gt;
&lt;li&gt;本科/武汉科技大学网络工程系&lt;/li&gt;
&lt;li&gt;工作年限：2年&lt;/li&gt;
&lt;li&gt;技术博客: http://yangm90.github.io&lt;/li&gt;
&lt;li&gt;期望职位：android工程师，android研发&lt;/li&gt;
&lt;li&gt;期望城市：北上广&lt;/li&gt;
&lt;li&gt;期望薪资：税前17k~20K&lt;/li&gt;
&lt;li&gt;QQ：89513196&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;

&lt;h1&gt;工作经历&lt;/h1&gt;

&lt;h2&gt;猎豹移动公司 （ 2012年7月 ~ 至今 ）&lt;/h2&gt;

&lt;h3&gt;cleanMatser的游戏加速 （2013年7月 ~ 至今）&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;我参与了研究如何帮助用户顺畅的玩游戏，找出游戏卡顿的原因。通过对android源码分析以及对用户的使用场景分析，找出了对用户有很大作用的点，是游戏盒子功能的留存得到了20%的提升。&lt;/li&gt;
&lt;li&gt;优化游戏盒子的启动框架，将游戏盒子的启动速度提升至竞品中最快（现在目前启动速度为0.7s）。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;金山手机助手（2012年7月 ~2013年7月）&lt;/h3&gt;

&lt;p&gt;这个项目中，主要参与几方面的事情：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将手机助手的各个模块降低耦合，并实现模块组件化，做到代码的动态加载，为内容的动态发布提供技术支持。&lt;/li&gt;
&lt;li&gt;将手机助手的数据库采用内存级数据库，将数据库读写分离，提升了数据吞吐速度。&lt;/li&gt;
&lt;li&gt;完善并且提高手机助手下载成功率，将手机助手的下载成功率从45%提升至60%。&lt;/li&gt;
&lt;li&gt;熟悉rootService，对root的相关操作熟悉。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;技能清单&lt;/h1&gt;

&lt;p&gt;以下均为我熟练使用的技能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;语言：Java/Android&lt;/li&gt;
&lt;li&gt;数据库相关：SQLite&lt;/li&gt;
&lt;li&gt;版本管理、：Svn/Git&lt;/li&gt;
&lt;li&gt;开发工具：android stdio,intellij idea , eclipse&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;

&lt;h1&gt;致谢&lt;/h1&gt;

&lt;p&gt;感谢您花时间阅读我的简历，期待能有机会和您共事。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>学习Activity启动过程分析</title>
     <link href="http://beiyuu.com/actvitystart"/>
     <updated>2015-01-23T00:00:00+08:00</updated>
     <id>http://beiyuu.com/actvitystart</id>
     <content type="html">&lt;p&gt;所有代码研究基于android4.2.2_R1&lt;/p&gt;

&lt;h2&gt;为何要研究Activity的启动过程:&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Activity其实是android提供的一个壳,供我们去学习如何以比较快的速度去完成一个app，但是本着知其然，知其所以然的心态，Activity的启动方式是值得研究的.&lt;/li&gt;
&lt;li&gt;Activity的启动过程中，我们可以看出activity与application是如何交互的，在哪些位置交互的.&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;简析Activity启动过程&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/android/android_activity_startservice.jpeg&quot; title=&quot;Optional title&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面这个图显示的一个外部调用ActivityManagerService去生成一个全新的Activity(包括生成这个Activity所在的application).这个图还包括了如何生成一个新的service。&lt;/p&gt;

&lt;h3&gt;在Launch点击了图片开始:&lt;/h3&gt;

&lt;p&gt;在Android系统中，应用程序是由Launcher启动起来的，其实，Launcher本身也是一个应用程序，其它的应用程序安装后，就会Launcher的界面上出现一个相应的图标，点击这个图标时，Launcher就会对应的应用程序启动起来。
 Launcher的源代码工程在packages/apps/Launcher2目录下，负责启动其它应用程序的源代码实现在src/com/android/launcher2/Launcher.java文件中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java &quot;&gt;/**
* Default launcher application.
*/
public final class Launcher extends Activity
        implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks, AllAppsView.Watcher {

    ......

    /**
    * Launches the intent referred by the clicked shortcut.
    *
    * @param v The view representing the clicked shortcut.
    */
    public void onClick(View v) {
        Object tag = v.getTag();
        if (tag instanceof ShortcutInfo) {
            // Open shortcut
            final Intent intent = ((ShortcutInfo) tag).intent;
            int[] pos = new int[2];
            v.getLocationOnScreen(pos);
            intent.setSourceBounds(new Rect(pos[0], pos[1],
                pos[0] + v.getWidth(), pos[1] + v.getHeight()));
            startActivitySafely(intent, tag);
        } else if (tag instanceof FolderInfo) {
            ......
        } else if (v == mHandleView) {
            ......
        }
    }

    void startActivitySafely(Intent intent, Object tag) {
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        try {
            startActivity(intent);
        } catch (ActivityNotFoundException e) {
            ......
        } catch (SecurityException e) {
            ......
        }
    }

    ......

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般的activity的AndroidManifest.xml为：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&amp;lt;activity android:name=&amp;quot;.MainActivity&amp;quot;  
      android:label=&amp;quot;@string/app_name&amp;quot;&amp;gt;  
       &amp;lt;intent-filter&amp;gt;  
        &amp;lt;action android:name=&amp;quot;android.intent.action.MAIN&amp;quot; /&amp;gt;  
        &amp;lt;category android:name=&amp;quot;android.intent.category.LAUNCHER&amp;quot; /&amp;gt;  
    &amp;lt;/intent-filter&amp;gt;  
&amp;lt;/activity&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因此，这里的intent包含的信息为：action = &quot;android.intent.action.Main&quot;，category=&quot;android.intent.category.LAUNCHER&quot;, cmp=&quot;shy.luo.activity/.MainActivity&quot;，表示它要启动的Activity为shy.luo.activity.MainActivity。&lt;/p&gt;

&lt;p&gt;Intent.FLAG_ACTIVITY_NEW_TASK表示要在一个新的Task中启动这个Activity，注意，Task是Android系统中的概念，它不同于进程Process的概念。简单地说，一个Task是一系列Activity的集合，这个集合是以堆栈的形式来组织的，遵循后进先出的原则。事实上，Task是一个非常复杂的概念，有兴趣的读者可以到官网http://developer.android.com/guide/topics/manifest/activity-element.html查看相关的资料。这里，我们只要知道，这个MainActivity要在一个新的Task中启动就可以了。&lt;/p&gt;

&lt;p&gt;调用的Activity的startActivity:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Override
    public void startActivity(Intent intent) {
        startActivity(intent, null);
    }
    
    @Override
    public void startActivity(Intent intent, Bundle options) {
        if (options != null) {
            startActivityForResult(intent, -1, options);
        } else {
            // Note we want to go through this call for compatibility with
            // applications that may have overridden the method.
            startActivityForResult(intent, -1);
        }
    }

    public void startActivityForResult(Intent intent, int requestCode, Bundle options) {
        if (mParent == null) {
            Instrumentation.ActivityResult ar =
                mInstrumentation.execStartActivity(
                    this, mMainThread.getApplicationThread(), mToken, this,
                    intent, requestCode, options);
            if (ar != null) {
                mMainThread.sendActivityResult(
                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),
                    ar.getResultData());
            }
            if (requestCode &amp;gt;= 0) {
                // If this start is requesting a result, we can avoid making
                // the activity visible until the result is received.  Setting
                // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
                // activity hidden during this time, to avoid flickering.
                // This can only be done when a result is requested because
                // that guarantees we will get information back when the
                // activity is finished, no matter what happens to it.
                mStartedActivity = true;
            }

        } 
            ......
   }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第一次mParent为空，因此调用的mInstrumentation.execStartActivity,类型为mInstrumentation。这里的mMainThread也是Activity类的成员变量，它的类型是ActivityThread，它代表的是应用程序的主线程。&lt;/p&gt;

&lt;p&gt;这里的mToken也是Activity类的成员变量，它是一个Binder对象的远程接口。&lt;/p&gt;

&lt;p&gt;看下Instrumentation的代码:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public ActivityResult execStartActivity(
            Context who, IBinder contextThread, IBinder token, Activity target,
            Intent intent, int requestCode, Bundle options) {
        IApplicationThread whoThread = (IApplicationThread) contextThread;
        ......        
        try {
            intent.setAllowFds(false);
            intent.migrateExtraStreamToClipData();
            int result = ActivityManagerNative.getDefault()
                .startActivity(whoThread, intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target != null ? target.mEmbeddedID : null,
                        requestCode, 0, null, null, options);
            checkStartActivityResult(result, intent);
        } catch (RemoteException e) {
        }
        return null;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 这里的ActivityManagerNative.getDefault返回ActivityManagerService的远程接口，即ActivityManagerProxy接口。&lt;/p&gt;

&lt;p&gt;我们看ActivityManagerService.startActivity&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public final int startActivity(IApplicationThread caller,
            Intent intent, String resolvedType, IBinder resultTo,
            String resultWho, int requestCode, int startFlags,
            String profileFile, ParcelFileDescriptor profileFd, Bundle options) {
        return startActivityAsUser(caller, intent, resolvedType, resultTo, resultWho, requestCode,
                startFlags, profileFile, profileFd, options, UserHandle.getCallingUserId());
    }

    public final int startActivityAsUser(IApplicationThread caller,
            Intent intent, String resolvedType, IBinder resultTo,
            String resultWho, int requestCode, int startFlags,
            String profileFile, ParcelFileDescriptor profileFd, Bundle options, int userId) {
        enforceNotIsolatedCaller(&amp;quot;startActivity&amp;quot;);
        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,
                false, true, &amp;quot;startActivity&amp;quot;, null);
        return mMainStack.startActivityMayWait(caller, -1, intent, resolvedType,
                resultTo, resultWho, requestCode, startFlags, profileFile, profileFd,
                null, null, options, userId);
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里只是简单地将操作转发给成员变量mMainStack的startActivityMayWait函数，这里的mMainStack的类型为ActivityStack。
查看startActivityMayWait&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;final int startActivityMayWait(IApplicationThread caller, int callingUid,
            Intent intent, String resolvedType, IBinder resultTo,
            String resultWho, int requestCode, int startFlags, String profileFile,
            ParcelFileDescriptor profileFd, WaitResult outResult, Configuration config,
            Bundle options, int userId) {

        // Don&amp;#39;t modify the client&amp;#39;s object!
        intent = new Intent(intent);

        // Collect information about the target of the Intent.
        ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags,
                profileFile, profileFd, userId);
        .......
        try {
            ResolveInfo rInfo =
            AppGlobals.getPackageManager().resolveIntent(
                ntent, null,
                PackageManager.MATCH_DEFAULT_ONLY
                 | ActivityManagerService.STOCK_PM_FLAGS, userId);
            Info = rInfo != null ? rInfo.activityInfo : null;
            aInfo = mService.getActivityInfoForUser(aInfo, userId);
            } catch (RemoteException e) {
            aInfo = null;
        }
        int res = startActivityLocked(caller, intent, resolvedType,
                    aInfo, resultTo, resultWho, requestCode, callingPid, callingUid,
                    startFlags, options, componentSpecified, null);


        return res;  

    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的代码真的很长，但是大部分不用关心：
要注意的是·&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;try {
            ResolveInfo rInfo =
            AppGlobals.getPackageManager().resolveIntent(
                ntent, null,
                PackageManager.MATCH_DEFAULT_ONLY
                 | ActivityManagerService.STOCK_PM_FLAGS, userId);
            Info = rInfo != null ? rInfo.activityInfo : null;
            aInfo = mService.getActivityInfoForUser(aInfo, userId);
            } catch (RemoteException e) {
            }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的aInfo就是AndroidManifest.xml里面配置的。&lt;/p&gt;

&lt;p&gt; 接下去就调用startActivityLocked进一步处理了。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;final int startActivityLocked(IApplicationThread caller,
            Intent intent, String resolvedType, ActivityInfo aInfo, IBinder resultTo,
            String resultWho, int requestCode,
            int callingPid, int callingUid, int startFlags, Bundle options,
            boolean componentSpecified, ActivityRecord[] outActivity) {

        int err = ActivityManager.START_SUCCESS;

         if (caller != null) {  
            callerApp = mService.getRecordForAppLocked(caller);  
            if (callerApp != null) {  
                callingPid = callerApp.pid;  
                callingUid = callerApp.info.uid;  
            } else {  
                ......  
            }  
        }  

       ......
    
        ActivityRecord sourceRecord = null;
        ActivityRecord resultRecord = null;
        if (resultTo != null) {
            int index = indexOfTokenLocked(resultTo);
            if (DEBUG_RESULTS) Slog.v(
                TAG, &amp;quot;Will send result to &amp;quot; + resultTo + &amp;quot; (index &amp;quot; + index + &amp;quot;)&amp;quot;);
            if (index &amp;gt;= 0) {
                sourceRecord = mHistory.get(index);
                if (requestCode &amp;gt;= 0 &amp;amp;&amp;amp; !sourceRecord.finishing) {
                    resultRecord = sourceRecord;
                }
            }
        }

        int launchFlags = intent.getFlags();

        if ((launchFlags&amp;amp;Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0
                &amp;amp;&amp;amp; sourceRecord != null) {
            // Transfer the result target from the source activity to the new
            // one being started, including any failures.
            if (requestCode &amp;gt;= 0) {
                ActivityOptions.abort(options);
                return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
            }
            resultRecord = sourceRecord.resultTo;
            resultWho = sourceRecord.resultWho;
            requestCode = sourceRecord.requestCode;
            sourceRecord.resultTo = null;
            if (resultRecord != null) {
                resultRecord.removeResultsLocked(
                    sourceRecord, resultWho, requestCode);
            }
        }

        if (err == ActivityManager.START_SUCCESS &amp;amp;&amp;amp; intent.getComponent() == null) {
            // We couldn&amp;#39;t find a class that can handle the given Intent.
            // That&amp;#39;s the end of that!
            err = ActivityManager.START_INTENT_NOT_RESOLVED;
        }

        if (err == ActivityManager.START_SUCCESS &amp;amp;&amp;amp; aInfo == null) {
            // We couldn&amp;#39;t find the specific class specified in the Intent.
            // Also the end of the line.
            err = ActivityManager.START_CLASS_NOT_FOUND;
        }

        if (err != ActivityManager.START_SUCCESS) {
            if (resultRecord != null) {
                sendActivityResultLocked(-1,
                    resultRecord, resultWho, requestCode,
                    Activity.RESULT_CANCELED, null);
            }
            mDismissKeyguardOnNextActivity = false;
            ActivityOptions.abort(options);
            return err;
        }
            ......

        ActivityRecord r = new ActivityRecord(mService, this, callerApp, callingUid,
                intent, resolvedType, aInfo, mService.mConfiguration,
                resultRecord, resultWho, requestCode, componentSpecified);
        if (outActivity != null) {
            outActivity[0] = r;
        }

        if (mMainStack) {
            if (mResumedActivity == null
                    || mResumedActivity.info.applicationInfo.uid != callingUid) {
                if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid, &amp;quot;Activity start&amp;quot;)) {
                    PendingActivityLaunch pal = new PendingActivityLaunch();
                    pal.r = r;
                    pal.sourceRecord = sourceRecord;
                    pal.startFlags = startFlags;
                    mService.mPendingActivityLaunches.add(pal);
                    mDismissKeyguardOnNextActivity = false;
                    ActivityOptions.abort(options);
                    return ActivityManager.START_SWITCHES_CANCELED;
                }
            }
        
            if (mService.mDidAppSwitch) {
                // This is the second allowed switch since we stopped switches,
                // so now just generally allow switches.  Use case: user presses
                // home (switches disabled, switch to home, mDidAppSwitch now true);
                // user taps a home icon (coming from home so allowed, we hit here
                // and now allow anyone to switch again).
                mService.mAppSwitchesAllowedTime = 0;
            } else {
                mService.mDidAppSwitch = true;
            }
         
            mService.doPendingActivityLaunchesLocked(false);
        }
        
        err = startActivityUncheckedLocked(r, sourceRecord,
                startFlags, true, options);
        if (mDismissKeyguardOnNextActivity &amp;amp;&amp;amp; mPausingActivity == null) {
            // Someone asked to have the keyguard dismissed on the next
            // activity start, but we are not actually doing an activity
            // switch...  just dismiss the keyguard now, because we
            // probably want to see whatever is behind it.
            mDismissKeyguardOnNextActivity = false;
            mService.mWindowManager.dismissKeyguard();
        }
        return err;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;之前说的caller就是调用者的进程信息，并保存在callerApp变量中,我们这里就是Launcher的进程信息。
resultTo则是调用的activity的信息。最终保存在sourceRecord中。
我们要创建Activity前会创建ActivityRecord.
 接着调用startActivityUncheckedLocked函数进行下一步操作。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;final int startActivityUncheckedLocked(ActivityRecord r,
            ActivityRecord sourceRecord, int startFlags, boolean doResume,
            Bundle options) {
        final Intent intent = r.intent;
        final int callingUid = r.launchedFromUid;

        int launchFlags = intent.getFlags();
        
        ...... 
       
        if (sourceRecord == null) {
            // This activity is not being started from another...  in this
            // case we -always- start a new task.
            launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
            
        } else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
            // The original activity who is starting us is running as a single
            // instance...  this new activity it is starting must go on its
            // own task.
            launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
        } else if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE
                || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            // The activity being started is a single instance...  it always
            // gets launched into its own task.
            launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
        }

        if (r.resultTo != null &amp;amp;&amp;amp; (launchFlags&amp;amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
            // For whatever reason this activity is being launched into a new
            // task...  yet the caller has requested a result back.  Well, that
            // is pretty messed up, so instead immediately send back a cancel
            // and let the new task continue launched as normal without a
            // dependency on its originator.
            Slog.w(TAG, &amp;quot;Activity is launching as a new task, so cancelling activity result.&amp;quot;);
            sendActivityResultLocked(-1,
                    r.resultTo, r.resultWho, r.requestCode,
                Activity.RESULT_CANCELED, null);
            r.resultTo = null;
        }

        boolean addingToTask = false;
        boolean movedHome = false;
        TaskRecord reuseTask = null;
        if (((launchFlags&amp;amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;amp;&amp;amp;
                (launchFlags&amp;amp;Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0)
                || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
                || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
            // If bring to front is requested, and no result is requested, and
            // we can find a task that was started with this same
            // component, then instead of launching bring that one to the front.
            if (r.resultTo == null) {
                ......
            }
    }


        if (r.packageName != null) {
            // If the activity being launched is the same as the one currently
            // at the top, then we need to check if it should only be launched
            // once.
            ActivityRecord top = topRunningNonDelayedActivityLocked(notTop);
            if (top != null &amp;amp;&amp;amp; r.resultTo == null) {
                if (top.realActivity.equals(r.realActivity) &amp;amp;&amp;amp; top.userId == r.userId) {
                    if (top.app != null &amp;amp;&amp;amp; top.app.thread != null) {
                        if ((launchFlags&amp;amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
                            || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP
                            || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
                        ......
                            ActivityOptions.abort(options);
                            if ((startFlags&amp;amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
                                // We don&amp;#39;t need to start a new activity, and
                                // the client said not to do anything if that
                                // is the case, so this is it!
                                return ActivityManager.START_RETURN_INTENT_TO_CALLER;
                            }
                            top.deliverNewIntentLocked(callingUid, r.intent);
                            return ActivityManager.START_DELIVERED_TO_TOP;
                        }
                    }
                }
            }

        } else {
            if (r.resultTo != null) {
                sendActivityResultLocked(-1,
                        r.resultTo, r.resultWho, r.requestCode,
                    Activity.RESULT_CANCELED, null);
            }
            ActivityOptions.abort(options);
            return ActivityManager.START_CLASS_NOT_FOUND;
        }

        boolean newTask = false;
        boolean keepCurTransition = false;

        // Should this be considered a new task?
        if (r.resultTo == null &amp;amp;&amp;amp; !addingToTask
                &amp;amp;&amp;amp; (launchFlags&amp;amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
            if (reuseTask == null) {
                // todo: should do better management of integers.
                mService.mCurTask++;
                if (mService.mCurTask &amp;lt;= 0) {
                    mService.mCurTask = 1;
                }
                r.setTask(new TaskRecord(mService.mCurTask, r.info, intent), null, true);
                if (DEBUG_TASKS) Slog.v(TAG, &amp;quot;Starting new activity &amp;quot; + r
                        + &amp;quot; in new task &amp;quot; + r.task);
            } else {
                r.setTask(reuseTask, reuseTask, true);
            }
            newTask = true;
            if (!movedHome) {
                moveHomeToFrontFromLaunchLocked(launchFlags);
            }
            
        } else if (sourceRecord != null) {
            if (!addingToTask &amp;amp;&amp;amp;
                    (launchFlags&amp;amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
                // In this case, we are adding the activity to an existing
                // task, but the caller has asked to clear that task if the
                // activity is already running.
                ActivityRecord top = performClearTaskLocked(
                        sourceRecord.task.taskId, r, launchFlags);
                keepCurTransition = true;
                if (top != null) {
                    logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);
                    top.deliverNewIntentLocked(callingUid, r.intent);
                    // For paranoia, make sure we have correctly
                    // resumed the top activity.
                    if (doResume) {
                        resumeTopActivityLocked(null);
                    }
                    ActivityOptions.abort(options);
                    return ActivityManager.START_DELIVERED_TO_TOP;
                }
            } else if (!addingToTask &amp;amp;&amp;amp;
                    (launchFlags&amp;amp;Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
                ......
        } else {
            ......
        }

        mService.grantUriPermissionFromIntentLocked(callingUid, r.packageName,
                intent, r.getUriPermissionsLocked());

        if (newTask) {
            EventLog.writeEvent(EventLogTags.AM_CREATE_TASK, r.userId, r.task.taskId);
        }
        logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task);
        startActivityLocked(r, newTask, doResume, keepCurTransition, options);
        return ActivityManager.START_SUCCESS;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个函数更长。我们来讲解下运行过程：
1. 函数首先获得intent的标志值，保存在launchFlags变量中。
2. 这个intent的标志值的位Intent.FLAG_ACTIVITY_NO_USER_ACTION没有置位，因此 ，成员变量mUserLeaving的值为true。
3. 这个intent的标志值的位Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP也没有置位，因此，变量notTop的值为null。
4. 由于在这个例子的AndroidManifest.xml文件中，MainActivity没有配置launchMode属值，因此，这里的r.launchMode为默认值0，表示以标准（Standard，或者称为ActivityInfo.LAUNCH_MULTIPLE）的方式来启动这个Activity。Activity的启动方式有四种，其余三种分别是ActivityInfo.LAUNCH_SINGLE_INSTANCE、ActivityInfo.LAUNCH_SINGLE_TASK和ActivityInfo.LAUNCH_SINGLE_TOP，具体可以参考官方网站。
5. 传进来的参数r.resultTo为null，表示Launcher不需要等这个即将要启动的MainActivity的执行结果
6. 由于这个intent的标志值的位Intent.FLAG_ACTIVITY_NEW_TASK被置位，而且Intent.FLAG_ACTIVITY_MULTIPLE_TASK没有置位，因此，下面的if语句会被执行：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;if (((launchFlags&amp;amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;amp;&amp;amp;
                (launchFlags&amp;amp;Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0)
                || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
                || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {

    if (r.resultTo == null) {  
        // See if there is a task to bring to the front.  If this is  
        // a SINGLE_INSTANCE activity, there can be one and only one  
        // instance of it in the history, and it is always in its own  
        // unique task, so we do a special search.  
        ActivityRecord taskTop = r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE  
            ? findTaskLocked(intent, r.info)  
            : findActivityLocked(intent, r.info);  
        if (taskTop != null) {  
            ......  
        }  
    }  
   }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;这段代码的逻辑是查看一下，当前有没有Task可以用来执行这个Activity。由于r.launchMode的值不为ActivityInfo.LAUNCH_SINGLE_INSTANCE，因此，它通过findTaskLocked函数来查找存不存这样的Task，这里返回的结果是null，即taskTop为null，因此，需要创建一个新的Task来启动这个Activity。&lt;/li&gt;
&lt;li&gt;执行到这里，我们知道，要在一个新的Task里面来启动这个Activity了，于是新创建一个Task：&lt;/li&gt;
&lt;/ol&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;if (r.resultTo == null &amp;amp;&amp;amp; !addingToTask
                &amp;amp;&amp;amp; (launchFlags&amp;amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
            if (reuseTask == null) {
                // todo: should do better management of integers.
                mService.mCurTask++;
                if (mService.mCurTask &amp;lt;= 0) {
                    mService.mCurTask = 1;
                }
                r.setTask(new TaskRecord(mService.mCurTask, r.info, intent), null, true);
                if (DEBUG_TASKS) Slog.v(TAG, &amp;quot;Starting new activity &amp;quot; + r
                        + &amp;quot; in new task &amp;quot; + r.task);
            } else {
                r.setTask(reuseTask, reuseTask, true);
            }
            newTask = true;
            if (!movedHome) {
                moveHomeToFrontFromLaunchLocked(launchFlags);
            }
            
        }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;新建的Task保存在r.task域中，同时，添加到mService中去，这里的mService就是ActivityManagerService了。&lt;/p&gt;

&lt;p&gt;分析函数,startActivityLocked.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;private final void startActivityLocked(ActivityRecord r, boolean newTask,
            boolean doResume, boolean keepCurTransition, Bundle options) {
        final int NH = mHistory.size();
        int addPos = -1;
        
            .....
        // Place a new activity at top of stack, so it is next to interact
        // with the user.
        if (addPos &amp;lt; 0) {
            addPos = NH;
        }
        
        // If we are not placing the new activity frontmost, we do not want
        // to deliver the onUserLeaving callback to the actual frontmost
        // activity
        if (addPos &amp;lt; NH) {
            mUserLeaving = false;
            if (DEBUG_USER_LEAVING) Slog.v(TAG, &amp;quot;startActivity() behind front, mUserLeaving=false&amp;quot;);
        }
        
        mHistory.add(addPos, r);
        r.putInHistory();
        r.frontOfTask = newTask;
        if (NH &amp;gt; 0) {
            // We want to show the starting preview window if we are
            // switching to a new task, or the next activity&amp;#39;s process is
            // not currently running.
            r.updateOptionsLocked(options);
                    .......
            mService.mWindowManager.addAppToken(
                    addPos, r.appToken, r.task.taskId, r.info.screenOrientation, r.fullscreen,
                    (r.info.flags &amp;amp; ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != 0);
            boolean doShow = true;
            if (SHOW_APP_STARTING_PREVIEW &amp;amp;&amp;amp; doShow) {
                // Figure out if we are transitioning from another activity that is
                // &amp;quot;has the same starting icon&amp;quot; as the next one.  This allows the
                // window manager to keep the previous window it had previously
                // created, if it still had one.
                ActivityRecord prev = mResumedActivity;
                if (prev != null) {
                    // We don&amp;#39;t want to reuse the previous starting preview if:
                    // (1) The current activity is in a different task.
                    if (prev.task != r.task) prev = null;
                    // (2) The current activity is already displayed.
                    else if (prev.nowVisible) prev = null;
                }
                mService.mWindowManager.setAppStartingWindow(
                        r.appToken, r.packageName, r.theme,
                        mService.compatibilityInfoForPackageLocked(
                                r.info.applicationInfo), r.nonLocalizedLabel,
                        r.labelRes, r.icon, r.windowFlags,
                        prev != null ? prev.appToken : null, showStartingIcon);
            }
        } else {
            // If this is the first activity, don&amp;#39;t do any fancy animations,
            // because there is nothing for it to animate on top of.
            mService.mWindowManager.addAppToken(addPos, r.appToken, r.task.taskId,
                    r.info.screenOrientation, r.fullscreen,
                    (r.info.flags &amp;amp; ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != 0);
            ActivityOptions.abort(options);
        }
        if (VALIDATE_TOKENS) {
            validateAppTokensLocked();
        }

        if (doResume) {
            resumeTopActivityLocked(null);
        }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的NH表示当前系统中历史任务的个数，这里肯定是大于0，因为Launcher已经跑起来了。当NH&gt;0时，并且现在要切换新任务时，要做一些任务切的界面操作，这段代码我们就不看了，这里不会影响到下面启Activity的过程，有兴趣的读取可以自己研究一下。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class ActivityStack {

    ......

    /**
    * Ensure that the top activity in the stack is resumed.
    *
    * @param prev The previously resumed activity, for when in the process
    * of pausing; can be null to call from elsewhere.
    *
    * @return Returns true if something is being resumed, or false if
    * nothing happened.
    */
    final boolean resumeTopActivityLocked(ActivityRecord prev) {
        // Find the first activity that is not finishing.
        ActivityRecord next = topRunningActivityLocked(null);

        // Remember how we&amp;#39;ll process this pause/resume situation, and ensure
        // that the state is reset however we wind up proceeding.
        final boolean userLeaving = mUserLeaving;
        mUserLeaving = false;

        if (next == null) {
            ......
        }

        next.delayedResume = false;

        // If the top activity is the resumed one, nothing to do.
        if (mResumedActivity == next &amp;amp;&amp;amp; next.state == ActivityState.RESUMED) {
            ......
        }

        // If we are sleeping, and there is no resumed activity, and the top
        // activity is paused, well that is the state we want.
        if ((mService.mSleeping || mService.mShuttingDown)
            &amp;amp;&amp;amp; mLastPausedActivity == next &amp;amp;&amp;amp; next.state == ActivityState.PAUSED) {
            ......
        }

        ......

        // If we are currently pausing an activity, then don&amp;#39;t do anything
        // until that is done.
        if (mPausingActivity != null) {
            ......
        }

        ......

        // We need to start pausing the current activity so the top one
        // can be resumed...
        if (mResumedActivity != null) {
            ......
            startPausingLocked(userLeaving, false);
            return true;
        }

        ......
    }

    ......

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;分析代码：
1. 函数先通过调用topRunningActivityLocked函数获得堆栈顶端的Activity，这里就是MainActivity了。
2. 接下来把mUserLeaving的保存在本地变量userLeaving中，然后重新设置为false，这里的userLeaving为true。
3. 这里的mResumedActivity为Launcher，因为Launcher是当前正被执行的Activity。
4. 当我们处理休眠状态时，mLastPausedActivity保存堆栈顶端的Activity，因为当前不是休眠状态，所以mLastPausedActivity为null。
5. 这样我们理解后面的代码就明白了&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;// If the top activity is the resumed one, nothing to do.
    if (mResumedActivity == next &amp;amp;&amp;amp; next.state == ActivityState.RESUMED) {
    ......
    }

    // If we are sleeping, and there is no resumed activity, and the top
    // activity is paused, well that is the state we want.
    if ((mService.mSleeping || mService.mShuttingDown)
    &amp;amp;&amp;amp; mLastPausedActivity == next &amp;amp;&amp;amp; next.state == ActivityState.PAUSED) {
    ......
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;&lt;p&gt;它首先看要启动的Activity是否就是当前处理Resumed状态的Activity，如果是的话，那就什么都不用做，直接返回就可以了；否则再看一下系统当前是否休眠状态，如果是的话，再看看要启动的Activity是否就是当前处于堆栈顶端的Activity，如果是的话，也是什么都不用做。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上面两个条件都不满足，因此，在继续往下执行之前，首先要把当处于Resumed状态的Activity推入Paused状态，然后才可以启动新的Activity。但是在将当前这个Resumed状态的Activity推入Paused状态之前，首先要看一下当前是否有Activity正在进入Pausing状态，如果有的话，当前这个Resumed状态的Activity就要稍后才能进入Paused状态了，这样就保证了所有需要进入Paused状态的Activity串行处理。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;这里没有处于Pausing状态的Activity，即mPausingActivity为null，而且mResumedActivity也不为null，于是就调用startPausingLocked函数把Launcher推入Paused状态去了。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;查看函数ActivityStack.startPausingLocked:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class ActivityStack {

    ......

    private final void startPausingLocked(boolean userLeaving, boolean uiSleeping) {
        if (mPausingActivity != null) {
            ......
        }
        ActivityRecord prev = mResumedActivity;
        if (prev == null) {
            ......
        }
        ......
        mResumedActivity = null;
        mPausingActivity = prev;
        mLastPausedActivity = prev;
        prev.state = ActivityState.PAUSING;
        ......

        if (prev.app != null &amp;amp;&amp;amp; prev.app.thread != null) {
            ......
            try {
                ......
                prev.app.thread.schedulePauseActivity(prev, prev.finishing, userLeaving,
                    prev.configChangeFlags);
                ......
            } catch (Exception e) {
                ......
            }
        } else {
            ......
        }

        ......
    
    }

    ......

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;函数首先把mResumedActivity保存在本地变量prev中。在上一步中，说到mResumedActivity就是Launcher，因此，这里把Launcher进程中的ApplicationThread对象取出来，通过它来通知Launcher这个Activity它要进入Paused状态了。当然，这里的prev.app.thread是一个ApplicationThread对象的远程接口，通过调用这个远程接口的schedulePauseActivity来通知Launcher进入Paused状态。&lt;/li&gt;
&lt;li&gt;参数prev.finishing表示prev所代表的Activity是否正在等待结束的Activity列表中，由于Laucher这个Activity还没结束，所以这里为false；参数prev.configChangeFlags表示哪些config发生了变化，这里我们不关心它的值。&lt;/li&gt;
&lt;li&gt;这里的调用的ApplicationThreadProxy.schedulePauseActivity,对应的service端代码为ApplicationThread.schedulePauseActivity.&lt;/li&gt;
&lt;/ol&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public final class ActivityThread {
    
    ......

    private final class ApplicationThread extends ApplicationThreadNative {
        
        ......

        public final void schedulePauseActivity(IBinder token, boolean finished,
                boolean userLeaving, int configChanges) {
            queueOrSendMessage(
                finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,
                token,
                (userLeaving ? 1 : 0),
                configChanges);
        }

        ......

    }

    // if the thread hasn&amp;#39;t started yet, we don&amp;#39;t have the handler, so just
    // save the messages until we&amp;#39;re ready.
    private void queueOrSendMessage(int what, Object obj) {
        queueOrSendMessage(what, obj, 0, 0);
    }

    private void queueOrSendMessage(int what, Object obj, int arg1, int arg2) {
        synchronized (this) {
            if (DEBUG_MESSAGES) Slog.v(
                TAG, &amp;quot;SCHEDULE &amp;quot; + what + &amp;quot; &amp;quot; + mH.codeToString(what)
                + &amp;quot;: &amp;quot; + arg1 + &amp;quot; / &amp;quot; + obj);
            Message msg = Message.obtain();
            msg.what = what;
            msg.obj = obj;
            msg.arg1 = arg1;
            msg.arg2 = arg2;
            mH.sendMessage(msg);
        }
    }

    ......
    private class H extends Handler {


        public void handleMessage(Message msg) {
        ......
                case PAUSE_ACTIVITY:
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &amp;quot;activityPause&amp;quot;);
                    handlePauseActivity((IBinder)msg.obj, false, msg.arg1 != 0, msg.arg2);
                    maybeSnapshot();
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                    break;
                case PAUSE_ACTIVITY_FINISHING:
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &amp;quot;activityPause&amp;quot;);
                    handlePauseActivity((IBinder)msg.obj, true, msg.arg1 != 0, msg.arg2);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                    break;
        ......

        }
    }

    private void handlePauseActivity(IBinder token, boolean finished,
            boolean userLeaving, int configChanges) {
        ActivityClientRecord r = mActivities.get(token);
        if (r != null) {
            //Slog.v(TAG, &amp;quot;userLeaving=&amp;quot; + userLeaving + &amp;quot; handling pause of &amp;quot; + r);
            if (userLeaving) {
                performUserLeavingActivity(r);
            }

            r.activity.mConfigChangeFlags |= configChanges;
            performPauseActivity(token, finished, r.isPreHoneycomb());

            // Make sure any pending writes are now committed.
            if (r.isPreHoneycomb()) {
                QueuedWork.waitToFinish();
            }

            // Tell the activity manager we have paused.
            try {
                ActivityManagerNative.getDefault().activityPaused(token);
            } catch (RemoteException ex) {
            }
        }
    }

    ......

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最终要看的函数其实就是handlePauseActivity,函数首先将Binder引用token转换成ActivityRecord的远程接口ActivityClientRecord，然后做了三个事情:
1. 如果userLeaving为true，则通过调用performUserLeavingActivity函数来调用Activity.onUserLeaveHint通知Activity，用户要离开它了.
2. 调用performPauseActivity函数来调用Activity.onPause函数，我们知道，在Activity的生命周期中，当它要让位于其它的Activity时，系统就会调用它的onPause函数.
3. 它通知ActivityManagerService，这个Activity已经进入Paused状态了，ActivityManagerService现在可以完成未竟的事情，即启动MainActivity了。&lt;/p&gt;

&lt;p&gt;这里的ActivityManagerNative.getDefault() 最终指向的是ActivityManagerService。
ActivityManagerService.activityPaused():&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public final void activityPaused(IBinder token) {
        final long origId = Binder.clearCallingIdentity();
        mMainStack.activityPaused(token, false);
        Binder.restoreCallingIdentity(origId);
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;又再次进入到ActivityStack类中，执行activityPaused函数。
这个函数定义在frameworks/base/services/java/com/android/server/am/ActivityStack.java文件中&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;final void activityPaused(IBinder token, boolean timeout) {
        if (DEBUG_PAUSE) Slog.v(
            TAG, &amp;quot;Activity paused: token=&amp;quot; + token + &amp;quot;, timeout=&amp;quot; + timeout);

        ActivityRecord r = null;

        synchronized (mService) {
            int index = indexOfTokenLocked(token);
            if (index &amp;gt;= 0) {
                r = mHistory.get(index);
                mHandler.removeMessages(PAUSE_TIMEOUT_MSG, r);
                if (mPausingActivity == r) {
                    if (DEBUG_STATES) Slog.v(TAG, &amp;quot;Moving to PAUSED: &amp;quot; + r
                            + (timeout ? &amp;quot; (due to timeout)&amp;quot; : &amp;quot; (pause complete)&amp;quot;));
                    r.state = ActivityState.PAUSED;
                    completePauseLocked();
                } else {
                    EventLog.writeEvent(EventLogTags.AM_FAILED_TO_PAUSE,
                            r.userId, System.identityHashCode(r), r.shortComponentName, 
                            mPausingActivity != null
                                ? mPausingActivity.shortComponentName : &amp;quot;(none)&amp;quot;);
                }
            }
        }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里通过参数token在mHistory列表中得到ActivityRecord，从上面我们知道，这个ActivityRecord代表的是Launcher这个Activity,之前将Launcher这个Activity的信息保存在mPausingActivity中，因此，这里mPausingActivity等于r，于是，执行completePauseLocked操作。
ActivityStack.completePauseLocked&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class ActivityStack {

    ......

    private final void completePauseLocked() {
        ActivityRecord prev = mPausingActivity;
        
        ......

        if (prev != null) {

            ......

            mPausingActivity = null;
        }

        if (!mService.mSleeping &amp;amp;&amp;amp; !mService.mShuttingDown) {
            resumeTopActivityLocked(prev);
        } else {
            ......
        }

        ......
    }

    ......

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数首先把mPausingActivity变量清空，因为现在不需要它了，然后调用resumeTopActivityLokced进一步操作，它传入的参数即为代表Launcher这个Activity的ActivityRecord。&lt;/p&gt;

&lt;p&gt;再次看看我们熟悉的resumeTopActivityLocked.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class ActivityStack {

    ......

    final boolean resumeTopActivityLocked(ActivityRecord prev) {
        ......

        // Find the first activity that is not finishing.
        ActivityRecord next = topRunningActivityLocked(null);

        // Remember how we&amp;#39;ll process this pause/resume situation, and ensure
        // that the state is reset however we wind up proceeding.
        final boolean userLeaving = mUserLeaving;
        mUserLeaving = false;

        ......

        next.delayedResume = false;

        // If the top activity is the resumed one, nothing to do.
        if (mResumedActivity == next &amp;amp;&amp;amp; next.state == ActivityState.RESUMED) {
            ......
            return false;
        }

        // If we are sleeping, and there is no resumed activity, and the top
        // activity is paused, well that is the state we want.
        if ((mService.mSleeping || mService.mShuttingDown)
            &amp;amp;&amp;amp; mLastPausedActivity == next &amp;amp;&amp;amp; next.state == ActivityState.PAUSED) {
            ......
            return false;
        }

        .......


        // We need to start pausing the current activity so the top one
        // can be resumed...
        if (mResumedActivity != null) {
            ......
            return true;
        }

        ......


        if (next.app != null &amp;amp;&amp;amp; next.app.thread != null) {
            ......

        } else {
            ......
            startSpecificActivityLocked(next, true, true);
        }

        return true;
    }
    ......
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们知道，当前在堆栈顶端的Activity为我们即将要启动的MainActivity，这里通过调用topRunningActivityLocked将它取回来，保存在next变量中。之前最后一个Resumed状态的Activity，即Launcher，到了这里已经处于Paused状态了，因此，mResumedActivity为null。最后一个处于Paused状态的Activity为Launcher，因此，这里的mLastPausedActivity就为Launcher。前面我们为MainActivity创建了ActivityRecord后，它的app域一直保持为null。有了这些信息后，上面这段代码就容易理解了，它最终调用startSpecificActivityLocked进行下一步操作。
查看 startSpecificActivityLocked函数:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class ActivityStack {

    ......

    private final void startSpecificActivityLocked(ActivityRecord r,
            boolean andResume, boolean checkConfig) {
        // Is this activity&amp;#39;s application already running?
        ProcessRecord app = mService.getProcessRecordLocked(r.processName,
            r.info.applicationInfo.uid);

        ......

        if (app != null &amp;amp;&amp;amp; app.thread != null) {
            try {
                realStartActivityLocked(r, app, andResume, checkConfig);
                return;
            } catch (RemoteException e) {
                ......
            }
        }

        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,
            &amp;quot;activity&amp;quot;, r.intent.getComponent(), false);
    }
    ......
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于第一次启动这个应用APP，所以app为null，执行mService.startProcessLocked.
也就是调用的ActivityManagerService.startProcessLocked.
查看函数startProcessLocked.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public final class ActivityManagerService extends ActivityManagerNative
        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {

    ......

    final ProcessRecord startProcessLocked(String processName,
            ApplicationInfo info, boolean knownToBeDead, int intentFlags,
            String hostingType, ComponentName hostingName, boolean allowWhileBooting) {

        ProcessRecord app = getProcessRecordLocked(processName, info.uid);
        
        ......

        String hostingNameStr = hostingName != null
            ? hostingName.flattenToShortString() : null;

        ......

        if (app == null) {
            app = newProcessRecordLocked(null, info, processName);
            mProcessNames.put(processName, info.uid, app);
        } else {
            // If this is a new package in the process, add the package to the list
            app.addPackage(info.packageName);
        }

        ......

        startProcessLocked(app, hostingType, hostingNameStr);
        return (app.pid != 0) ? app : null;
    }
    ......
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里会根据pid跟processname去检查ProcessRecord是否存在，如果不存在则生成新的record.我们这里是不存在的.所以会new出新的record，然后最后执行startProcessLocked。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public final class ActivityManagerService extends ActivityManagerNative
        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {

    ......

    private final void startProcessLocked(ProcessRecord app,
                String hostingType, String hostingNameStr) {

        ......

        try {
            int uid = app.info.uid;
            int[] gids = null;
            try {
                gids = mContext.getPackageManager().getPackageGids(
                    app.info.packageName);
            } catch (PackageManager.NameNotFoundException e) {
                ......
            }
            
            ......

            int debugFlags = 0;
            
            ......
            
            // Start the process.  It will either succeed and return a result containing
            // the PID of the new process, or else throw a RuntimeException.
            Process.ProcessStartResult startResult = Process.start(&amp;quot;android.app.ActivityThread&amp;quot;,
                    app.processName, uid, uid, gids, debugFlags, mountExternal,
                    app.info.targetSdkVersion, null, null);         
            ......

            if (app.persistent) {
                Watchdog.getInstance().processStarted(app.processName, startResult.pid);
            }

        } catch (RuntimeException e) {
            
            ......

        }
    }

    ......

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里主要是调用Process.start接口来创建一个新的进程，新的进程会导入android.app.ActivityThread类，并且执行它的main函数，这就是为什么我们前面说每一个应用程序都有一个ActivityThread实例来对应的原因。
查看ActivityThread.java的main方法。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public final class ActivityThread {

    ......

    private final void attach(boolean system) {
        ......

        mSystemThread = system;
        if (!system) {

            ......

            IActivityManager mgr = ActivityManagerNative.getDefault();
            try {
                mgr.attachApplication(mAppThread);
            } catch (RemoteException ex) {
            }
        } else {

            ......

        }
    }

    ......

    public static final void main(String[] args) {
        
        .......

        ActivityThread thread = new ActivityThread();
        thread.attach(false);

        ......

        Looper.loop();

        .......

        thread.detach();
        
        ......
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 这个函数在进程中创建一个ActivityThread实例，然后调用它的attach函数，接着就进入消息循环了，直到最后进程退出。
 函数attach最终调用了ActivityManagerService的远程接口ActivityManagerProxy的attachApplication函数，传入的参数是mAppThread，这是一个ApplicationThread类型的Binder对象，它的作用是用来进行进程间通信的。
查看代码 ActivityManagerService.attachApplication&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public final void attachApplication(IApplicationThread thread) {
        synchronized (this) {
            int callingPid = Binder.getCallingPid();
            final long origId = Binder.clearCallingIdentity();
            attachApplicationLocked(thread, callingPid);
            Binder.restoreCallingIdentity(origId);
        }
    }


private final boolean attachApplicationLocked(IApplicationThread thread,
            int pid) {

        // Find the application record that is being attached...  either via
        // the pid if we are running in multiple processes, or just pull the
        // next app record if we are emulating process with anonymous threads.
        ProcessRecord app;

        ......

        if (pid != MY_PID &amp;amp;&amp;amp; pid &amp;gt;= 0) {
            synchronized (mPidsSelfLocked) {
                app = mPidsSelfLocked.get(pid);
            }
        } else {
            app = null;
        }

        ......

        String processName = app.processName;
        try {
            AppDeathRecipient adr = new AppDeathRecipient(
                    app, pid, thread);
            thread.asBinder().linkToDeath(adr, 0);
            app.deathRecipient = adr;
        } catch (RemoteException e) {
            app.resetPackageList();
            startProcessLocked(app, &amp;quot;link fail&amp;quot;, processName);
            return false;
        }
        
        app.thread = thread;
        app.curAdj = app.setAdj = -100;
        app.curSchedGroup = Process.THREAD_GROUP_DEFAULT;
        app.setSchedGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE;
        app.forcingToForeground = null;
        app.foregroundServices = false;
        app.hasShownUi = false;
        app.debugging = false;

        mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);

        boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info);
        List providers = normalMode ? generateApplicationProvidersLocked(app) : null;

        // Remove this record from the list of starting applications.
        mPersistentStartingProcesses.remove(app);

        mProcessesOnHold.remove(app);

        boolean badApp = false;
        boolean didSomething = false;

        // See if the top visible activity is waiting to run in this process...
        ActivityRecord hr = mMainStack.topRunningActivityLocked(null);
        if (hr != null &amp;amp;&amp;amp; normalMode) {
            if (hr.app == null &amp;amp;&amp;amp; app.uid == hr.info.applicationInfo.uid
                    &amp;amp;&amp;amp; processName.equals(hr.processName)) {
                try {
                    if (mHeadless) {
                        Slog.e(TAG, &amp;quot;Starting activities not supported on headless device: &amp;quot; + hr);
                    } else if (mMainStack.realStartActivityLocked(hr, app, true, true)) {
                        didSomething = true;
                    }
                } catch (Exception e) {
                    badApp = true;
                }
            } else {
                mMainStack.ensureActivitiesVisibleLocked(hr, null, processName, 0);
            }
        }

        // Find any services that should be running in this process...
        if (!badApp) {
            try {
                didSomething |= mServices.attachApplicationLocked(app, processName);
            } catch (Exception e) {
                badApp = true;
            }
        }

        // Check if a next-broadcast receiver is in this process...
        if (!badApp &amp;amp;&amp;amp; isPendingBroadcastProcessLocked(pid)) {
            try {
                didSomething = sendPendingBroadcastsLocked(app);
            } catch (Exception e) {
                // If the app died trying to launch the receiver we declare it &amp;#39;bad&amp;#39;
                badApp = true;
            }
        }
        ......

        return true;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;  已经创建了一个ProcessRecord，这里首先通过pid将它取回来，放在app变量中，然后对app的其它成员进行初始化，最后调用mMainStack.realStartActivityLocked执行真正的Activity启动操作。这里要启动的Activity通过调用mMainStack.topRunningActivityLocked(null)从堆栈顶端取回来，这时候在堆栈顶端的Activity就是MainActivity了。
查看ActivityStack.java的realStartActivityLocked&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class ActivityStack {

    ......

    final boolean realStartActivityLocked(ActivityRecord r,
            ProcessRecord app, boolean andResume, boolean checkConfig)
            throws RemoteException {
        
        ......

        r.app = app;

        ......

        int idx = app.activities.indexOf(r);
        if (idx &amp;lt; 0) {
            app.activities.add(r);
        }
        
        ......

        try {
            ......

            List&amp;lt;ResultInfo&amp;gt; results = null;
            List&amp;lt;Intent&amp;gt; newIntents = null;
            if (andResume) {
                results = r.results;
                newIntents = r.newIntents;
            }
    
            ......
            
            app.thread.scheduleLaunchActivity(new Intent(r.intent), r,
                System.identityHashCode(r),
                r.info, r.icicle, results, newIntents, !andResume,
                mService.isNextTransitionForward());

            ......

        } catch (RemoteException e) {
            ......
        }

        ......

        return true;
    }

    ......

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里最终通过app.thread进入到ApplicationThreadProxy的scheduleLaunchActivity函数中，注意，这里的第二个参数r，是一个ActivityRecord类型的Binder对象，用来作来这个Activity的token值。调用的远端的ActivityThread.的scheduleLaunchActivity函数.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,
                ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo,
                Bundle state, List&amp;lt;ResultInfo&amp;gt; pendingResults,
                List&amp;lt;Intent&amp;gt; pendingNewIntents, boolean notResumed, boolean isForward,
                String profileName, ParcelFileDescriptor profileFd, boolean autoStopProfiler) {
            ActivityClientRecord r = new ActivityClientRecord();

            r.token = token;
            r.ident = ident;
            r.intent = intent;
            r.activityInfo = info;
            r.compatInfo = compatInfo;
            r.state = state;

            r.pendingResults = pendingResults;
            r.pendingIntents = pendingNewIntents;

            r.startsNotResumed = notResumed;
            r.isForward = isForward;

            r.profileFile = profileName;
            r.profileFd = profileFd;
            r.autoStopProfiler = autoStopProfiler;

            updatePendingConfiguration(curConfig);

            queueOrSendMessage(H.LAUNCH_ACTIVITY, r);
        }

    private final class H extends Handler {

        ......

        public void handleMessage(Message msg) {
            ......
            switch (msg.what) {
            case LAUNCH_ACTIVITY: {
                ActivityClientRecord r = (ActivityClientRecord)msg.obj;

                r.packageInfo = getPackageInfoNoCheck(
                    r.activityInfo.applicationInfo);
                handleLaunchActivity(r, null);
            } break;
            ......
            }

        ......

    }

    private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {
        // If we are getting ready to gc after going to the background, well
        // we are back active so skip it.
        unscheduleGcIdler();

        ......
        Activity a = performLaunchActivity(r, customIntent);
        ......
        if (a != null) {
            r.createdConfig = new Configuration(mConfiguration);
            Bundle oldState = r.state;
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished &amp;amp;&amp;amp; !r.startsNotResumed);
        ......

    }
    ......
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;这里首先调用performLaunchActivity函数来加载这个Activity类，在performLaunchActivity中，如果没有application会先创建新的application，并调用application的onCreate方法。&lt;/li&gt;
&lt;li&gt;最后回到handleLaunchActivity函数时，再调用handleResumeActivity函数来使这个Activity进入Resumed状态，即会调用这个Activity的onResume函数，这是遵循Activity的生命周期的。
performLaunchActivity函数代码:&lt;/li&gt;
&lt;/ol&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
        ActivityInfo aInfo = r.activityInfo;
        if (r.packageInfo == null) {
            r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,
                    Context.CONTEXT_INCLUDE_CODE);
        }

        ComponentName component = r.intent.getComponent();
        if (component == null) {
            component = r.intent.resolveActivity(
                mInitialApplication.getPackageManager());
            r.intent.setComponent(component);
        }

        if (r.activityInfo.targetActivity != null) {
            component = new ComponentName(r.activityInfo.packageName,
                    r.activityInfo.targetActivity);
        }

        Activity activity = null;
        try {
            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
            StrictMode.incrementExpectedActivityCount(activity.getClass());
            r.intent.setExtrasClassLoader(cl);
            if (r.state != null) {
                r.state.setClassLoader(cl);
            }
        } catch (Exception e) {

        }

        try {
            Application app = r.packageInfo.makeApplication(false, mInstrumentation);

            if (activity != null) {
                Context appContext = createBaseContextForActivity(r, activity);
                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());
                Configuration config = new Configuration(mCompatConfiguration);
                if (DEBUG_CONFIGURATION) Slog.v(TAG, &amp;quot;Launching activity &amp;quot;
                        + r.activityInfo.name + &amp;quot; with config &amp;quot; + config);
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config);

                if (customIntent != null) {
                    activity.mIntent = customIntent;
                }
                r.lastNonConfigurationInstances = null;
                activity.mStartedActivity = false;
                int theme = r.activityInfo.getThemeResource();
                if (theme != 0) {
                    activity.setTheme(theme);
                }

                activity.mCalled = false;
                mInstrumentation.callActivityOnCreate(activity, r.state);
                if (!activity.mCalled) {
                    throw new SuperNotCalledException(
                        &amp;quot;Activity &amp;quot; + r.intent.getComponent().toShortString() +
                        &amp;quot; did not call through to super.onCreate()&amp;quot;);
                }
                r.activity = activity;
                r.stopped = true;
                if (!r.activity.mFinished) {
                    activity.performStart();
                    r.stopped = false;
                }
                if (!r.activity.mFinished) {
                    if (r.state != null) {
                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);
                    }
                }
                if (!r.activity.mFinished) {
                    activity.mCalled = false;
                    mInstrumentation.callActivityOnPostCreate(activity, r.state);
                    if (!activity.mCalled) {
                        throw new SuperNotCalledException(
                            &amp;quot;Activity &amp;quot; + r.intent.getComponent().toShortString() +
                            &amp;quot; did not call through to super.onPostCreate()&amp;quot;);
                    }
                }
            }
            r.paused = true;

            mActivities.put(r.token, r);

        } catch (SuperNotCalledException e) {
            throw e;

        } catch (Exception e) {
            if (!mInstrumentation.onException(activity, e)) {
                throw new RuntimeException(
                    &amp;quot;Unable to start activity &amp;quot; + component
                    + &amp;quot;: &amp;quot; + e.toString(), e);
            }
        }

        return activity;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数前面是收集要启动的Activity的相关信息，主要package和component信息&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;ActivityInfo aInfo = r.activityInfo;
   if (r.packageInfo == null) {
        r.packageInfo = getPackageInfo(aInfo.applicationInfo,
                Context.CONTEXT_INCLUDE_CODE);
   }

   ComponentName component = r.intent.getComponent();
   if (component == null) {
       component = r.intent.resolveActivity(
           mInitialApplication.getPackageManager());
       r.intent.setComponent(component);
   }

   if (r.activityInfo.targetActivity != null) {
       component = new ComponentName(r.activityInfo.packageName,
               r.activityInfo.targetActivity);
   }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 然后通过ClassLoader将目标的Activity的new出来&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;Activity activity = null;
   try {
    java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
    activity = mInstrumentation.newActivity(
        cl, component.getClassName(), r.intent);
    r.intent.setExtrasClassLoader(cl);
    if (r.state != null) {
        r.state.setClassLoader(cl);
    }
   } catch (Exception e) {
    ......
   }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来是创建Application对象，这是根据AndroidManifest.xml配置文件中的Application标签的信息来创建的：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;Application app = r.packageInfo.makeApplication(false, mInstrumentation);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;后面的代码主要创建Activity的上下文信息，并通过attach方法将这些上下文信息设置到MainActivity中去：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;Context appContext = createBaseContextForActivity(r, activity);
                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());
                Configuration config = new Configuration(mCompatConfiguration);
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config);

                if (customIntent != null) {
                    activity.mIntent = customIntent;
                }
                r.lastNonConfigurationInstances = null;
                activity.mStartedActivity = false;
                int theme = r.activityInfo.getThemeResource();
                if (theme != 0) {
                    activity.setTheme(theme);
                }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后还要调用MainActivity的onCreate函数：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;mInstrumentation.callActivityOnCreate(activity, r.state);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;结论&lt;/h3&gt;

&lt;p&gt;1.androd的底层实现是通过socket和共享内存的方式，这种写法也可以采用在我们自己的多进程通信上使用，值得学习
2.底层所有的event其实都是一样的，都是inputEvent，上层会根据source再分成keyEvent,MotionEvent等，用于不同的用处
3.所有View的起点其实就是dispatchPointerEvent()，这个是分发事件的起点.&lt;/p&gt;

&lt;h3&gt;参考blog&lt;/h3&gt;
</content>
   </entry>
   
   <entry>
     <title>Binder_analyse</title>
     <link href="http://beiyuu.com/binder_analyse"/>
     <updated>2015-01-15T00:00:00+08:00</updated>
     <id>http://beiyuu.com/binder_analyse</id>
     <content type="html">&lt;p&gt;所有代码研究基于android4.2.2_R1&lt;/p&gt;

&lt;h1&gt;从MediaService开始分析&lt;/h1&gt;

&lt;h2&gt;MediaService分析&lt;/h2&gt;

&lt;p&gt;framework\base\Media\MediaServer\Main_mediaserver.cpp&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;int main(int argc, char** argv)
{

//获得一个ProcessState实例
    sp&amp;lt;ProcessState&amp;gt; proc(ProcessState::self());

    //得到一个ServiceManager对象
    sp&amp;lt;IServiceManager&amp;gt; sm = defaultServiceManager();
    ALOGI(&amp;quot;ServiceManager: %p&amp;quot;, sm.get());
    AudioFlinger::instantiate();
    MediaPlayerService::instantiate();//初始化MediaPlayerService服务
    CameraService::instantiate();
    AudioPolicyService::instantiate();
    ProcessState::self()-&amp;gt;startThreadPool(); 
    IPCThreadState::self()-&amp;gt;joinThreadPool();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;ProcessState的&lt;/h2&gt;

&lt;p&gt;主要关注的是ProcessState,第一行就调用的是ProcessState::self().&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;sp&amp;lt;ProcessState&amp;gt; ProcessState::self()
{
    Mutex::Autolock _l(gProcessMutex);
    if (gProcess != NULL) {
        return gProcess;
    }
    gProcess = new ProcessState;
    return gProcess;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ProcessState的构造函数&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;ProcessState::ProcessState()
    : mDriverFD(open_driver())
    , mVMStart(MAP_FAILED)
    , mManagesContexts(false)
    , mBinderContextCheckFunc(NULL)
    , mBinderContextUserData(NULL)
    , mThreadPoolStarted(false)
    , mThreadPoolSeq(1)
{
    if (mDriverFD &amp;gt;= 0) {
        // XXX Ideally, there should be a specific define for whether we
        // have mmap (or whether we could possibly have the kernel module
        // availabla).
#if !defined(HAVE_WIN32_IPC)
        // mmap the binder, providing a chunk of virtual address space to receive transactions.
        mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);
        if (mVMStart == MAP_FAILED) {
            // *sigh*
            ALOGE(&amp;quot;Using /dev/binder failed: unable to mmap transaction memory.\n&amp;quot;);
            close(mDriverFD);
            mDriverFD = -1;
        }
#else
        mDriverFD = -1;
#endif
    }

    LOG_ALWAYS_FATAL_IF(mDriverFD &amp;lt; 0, &amp;quot;Binder driver could not be opened.  Terminating.&amp;quot;);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里已经调用open_driver()，open_driver，就是打开/dev/binder这个设备，这个是android在内核中搞的一个专门用于完成
进程间通讯而设置的一个虚拟的设备。BTW，说白了就是内核的提供的一个机制，这个和我们用socket加NET_LINK方式和内核通讯是一个道理。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;static int open_driver()
{
    int fd = open(&amp;quot;/dev/binder&amp;quot;, O_RDWR);
    if (fd &amp;gt;= 0) {
        fcntl(fd, F_SETFD, FD_CLOEXEC);
        int vers;
        status_t result = ioctl(fd, BINDER_VERSION, &amp;amp;vers);
        if (result == -1) {
            ALOGE(&amp;quot;Binder ioctl to obtain version failed: %s&amp;quot;, strerror(errno));
            close(fd);
            fd = -1;
        }
        if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) {
            ALOGE(&amp;quot;Binder driver protocol does not match user space protocol!&amp;quot;);
            close(fd);
            fd = -1;
        }
        size_t maxThreads = 15;
        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;amp;maxThreads);
        if (result == -1) {
            ALOGE(&amp;quot;Binder ioctl to set max threads failed: %s&amp;quot;, strerror(errno));
        }
    } else {
        ALOGW(&amp;quot;Opening &amp;#39;/dev/binder&amp;#39; failed: %s\n&amp;quot;, strerror(errno));
    }
    return fd;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;i
1. 打开/dev/binder设备，这样的话就相当于和内核binder机制有了交互的通道
2. 映射fd到内存，设备的fd传进去后，估计这块内存是和binder设备共享的&lt;/p&gt;

&lt;h2&gt;defaultServiceManager分析&lt;/h2&gt;

&lt;p&gt;defaultServiceManager位置在framework\base\libs\binder\IServiceManager.cpp中&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;sp&amp;lt;IServiceManager&amp;gt; defaultServiceManager()
{
    if (gDefaultServiceManager != NULL) return gDefaultServiceManager;
    
    {
        AutoMutex _l(gDefaultServiceManagerLock);
        if (gDefaultServiceManager == NULL) {
            //真正的gDefaultServiceManager是在这里创建的喔
            gDefaultServiceManager = interface_cast&amp;lt;IServiceManager&amp;gt;(
                ProcessState::self()-&amp;gt;getContextObject(NULL));
        }
    }
    
    return gDefaultServiceManager;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;分析代码就可以理解出来，其实调用是这样的&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;gDefaultServiceManager = interface_cast&amp;lt;IServiceManager&amp;gt;(new BpBinder(0));&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;interface_cast函数
\frameworks\native\include\binder\IInterface.h：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;template&amp;lt;typename INTERFACE&amp;gt;
inline sp&amp;lt;INTERFACE&amp;gt; interface_cast(const sp&amp;lt;IBinder&amp;gt;&amp;amp; obj)
{
    return INTERFACE::asInterface(obj);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结合前面就是：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;inline sp&amp;lt;IServiceManager&amp;gt; interface_cast(const sp&amp;lt;IBinder&amp;gt;&amp;amp; obj)
{
    return IServiceManager::asInterface(obj);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所以需要到IServiceManager里面去看看是如何实现的:  &lt;br/&gt;
\frameworks\native\include\binder\IServiceManager.h：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;class IServiceManager : public IInterface
{
public:
    DECLARE_META_INTERFACE(ServiceManager);
    /**
     * Retrieve an existing service, blocking for a few seconds
     * if it doesn&amp;#39;t yet exist.
     */
    virtual sp&amp;lt;IBinder&amp;gt;         getService( const String16&amp;amp; name) const = 0;

    /**
     * Retrieve an existing service, non-blocking.
     */
    virtual sp&amp;lt;IBinder&amp;gt;         checkService( const String16&amp;amp; name) const = 0;

    /**
     * Register a service.
     */
    virtual status_t            addService( const String16&amp;amp; name,
                                            const sp&amp;lt;IBinder&amp;gt;&amp;amp; service,
                                            bool allowIsolated = false) = 0;

    /**
     * Return list of all existing services.
     */
    virtual Vector&amp;lt;String16&amp;gt;    listServices() = 0;

    enum {
        GET_SERVICE_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,
        CHECK_SERVICE_TRANSACTION,
        ADD_SERVICE_TRANSACTION,
        LIST_SERVICES_TRANSACTION,
    };
};


//DECLARE_META_INTERFACE 声明: IInterface.h

#define DECLARE_META_INTERFACE(INTERFACE)                               \
    static const android::String16 descriptor;                          \
    static android::sp&amp;lt;I##INTERFACE&amp;gt; asInterface(                       \
            const android::sp&amp;lt;android::IBinder&amp;gt;&amp;amp; obj);                  \
    virtual const android::String16&amp;amp; getInterfaceDescriptor() const;    \
    I##INTERFACE();                                                     \
    virtual ~I##INTERFACE();                                            \&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;替换成IServiceManager：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;//实现时传入：android.os.IServiceManager
static const android::String16 descriptor; 
static android::sp&amp;lt;IServiceManager&amp;gt; asInterface( 
const android::sp&amp;lt;android::IBinder&amp;gt;&amp;amp; obj); 
virtual const android::String16&amp;amp; getInterfaceDescriptor() const; 
//构造析构函数
IServiceManager(); 
virtual ~IServiceManager();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;实现\frameworks\native\include\binder\IServiceManager.cpp：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;IMPLEMENT_META_INTERFACE(ServiceManager, &amp;quot;android.os.IServiceManager&amp;quot;);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;IMPLEMENT_META_INTERFACE实现：IInterface.h&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \
    const android::String16 I##INTERFACE::descriptor(NAME);             \
    const android::String16&amp;amp;                                            \
            I##INTERFACE::getInterfaceDescriptor() const {              \
        return I##INTERFACE::descriptor;                                \
    }                                                                   \
    android::sp&amp;lt;I##INTERFACE&amp;gt; I##INTERFACE::asInterface(                \
            const android::sp&amp;lt;android::IBinder&amp;gt;&amp;amp; obj)                   \
    {                                                                   \
        android::sp&amp;lt;I##INTERFACE&amp;gt; intr;                                 \
        if (obj != NULL) {                                              \
            intr = static_cast&amp;lt;I##INTERFACE*&amp;gt;(                          \
                obj-&amp;gt;queryLocalInterface(                               \
                        I##INTERFACE::descriptor).get());               \
            if (intr == NULL) {                                         \
                intr = new Bp##INTERFACE(obj);                          \
            }                                                           \
        }                                                               \
        return intr;                                                    \
    }                                                                   \
    I##INTERFACE::I##INTERFACE() { }                                    \
    I##INTERFACE::~I##INTERFACE() { }                                   \&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;替换成IServiceManager:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;android::sp&amp;lt;IServiceManager&amp;gt; IServiceManager::asInterface(                
            const android::sp&amp;lt;android::IBinder&amp;gt;&amp;amp; obj)                   
{   
        //obj BpBinder实例                                                                
        android::sp&amp;lt;IServiceManager&amp;gt; intr;                                
        if (obj != NULL) {
            //返回NULL                                        
            intr = static_cast&amp;lt;IServiceManager*&amp;gt;(                          
                obj-&amp;gt;queryLocalInterface(                               
                        IServiceManager::descriptor).get());              
            if (intr == NULL) {                                         
                intr = new BpServiceManager(obj);                          
            }                                                           
        }                                                               
        return intr;                                                    
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看出这个gDefaultServiceManager的实例其实是&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;BpServiceManager：new BpServiceManager（new BpBinder（0））；&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;BpServiceManager 和BpInterface&lt;/h2&gt;

&lt;p&gt;\frameworks\native\libs\binder\ IServiceManager.cpp：BpServiceManager&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;class BpServiceManager : public BpInterface&amp;lt;IServiceManager&amp;gt;
{
public:
      //impl就是 new BpBinder（0）
    BpServiceManager(const sp&amp;lt;IBinder&amp;gt;&amp;amp; impl)
        : BpInterface&amp;lt;IServiceManager&amp;gt;(impl)
    {
    }

    virtual sp&amp;lt;IBinder&amp;gt; checkService(const String16&amp;amp; name) const
    {
        ……
        remote()-&amp;gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;amp;reply);
    }

    virtual status_t addService(const String16&amp;amp; name, const sp&amp;lt;IBinder&amp;gt;&amp;amp; service,
            bool allowIsolated)
    {
        ……
        remote()-&amp;gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;amp;reply);
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;\frameworks\native\include\binder\ IInterface.h：模板类BpInterface&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;template&amp;lt;typename INTERFACE&amp;gt;
class BpInterface : public INTERFACE, public BpRefBase
{
public:
                                BpInterface(const sp&amp;lt;IBinder&amp;gt;&amp;amp; remote);

protected:
    virtual IBinder*            onAsBinder();
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;BpInterface的构造函数是空的就不用看了，直接看BpRefBase：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;BpRefBase::BpRefBase(const sp&amp;lt;IBinder&amp;gt;&amp;amp; o)
    : mRemote(o.get()), mRefs(NULL), mState(0)
{
    extendObjectLifetime(OBJECT_LIFETIME_WEAK);
    // IBinder mRemote 指向 o.get() ：new BpBinder（0）
    if (mRemote) {
        mRemote-&amp;gt;incStrong(this);           // Removed on first IncStrong().
        mRefs = mRemote-&amp;gt;createWeak(this);  // Held for our entire lifetime.
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(BpBinder(0))；
实际为：
　　gDefaultServiceManager = new BpServiceManager（new BpBinder（0））；
Bn代表Binder Native   Bp代表Binder Proxy
BpServiceManager代理的BpBinder实例 BpBinder代理的handle（0）&lt;/p&gt;

&lt;p&gt;在Media Process 的main函数中通过：&lt;/p&gt;

&lt;p&gt;sp&lt;IServiceManager&gt; sm = defaultServiceManager();
　　我们得到了sm：是BpServiceManager对象&lt;/p&gt;

&lt;p&gt;在回顾MediaPlayerService做了哪些:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;int main(int argc, char** argv)
{
    sp&amp;lt;ProcessState&amp;gt; proc(ProcessState::self());
    sp&amp;lt;IServiceManager&amp;gt; sm = defaultServiceManager();
    ALOGI(&amp;quot;ServiceManager: %p&amp;quot;, sm.get());
    AudioFlinger::instantiate();
    MediaPlayerService::instantiate();
    CameraService::instantiate();
    AudioPolicyService::instantiate();
    ProcessState::self()-&amp;gt;startThreadPool();
    IPCThreadState::self()-&amp;gt;joinThreadPool();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;MediaPlayerService初始化过程:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;void MediaPlayerService::instantiate() {
    defaultServiceManager()-&amp;gt;addService(
            String16(&amp;quot;media.player&amp;quot;), new MediaPlayerService());
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看BpServiceManager的addService方法&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;virtual status_t addService(const String16&amp;amp; name, const sp&amp;lt;IBinder&amp;gt;&amp;amp; service,
            bool allowIsolated)
    {
        Parcel data, reply;
        // Write RPC headers 写入Interface名字 得到“android.os.IServiceManager”
        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());
//写入Service名字 “media.player”
        data.writeString16(name);
//写入服务
        data.writeStrongBinder(service);
        data.writeInt32(allowIsolated ? 1 : 0);
// remote()返回BpBinder对象
        status_t err = remote()-&amp;gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;amp;reply);
        return err == NO_ERROR ? reply.readExceptionCode() : err;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;调用的是BpBinder的transact:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;status_t BpBinder::transact(
    uint32_t code, const Parcel&amp;amp; data, Parcel* reply, uint32_t flags)
{
    // Once a binder has died, it will never come back to life.
    if (mAlive) {
        status_t status = IPCThreadState::self()-&amp;gt;transact(
            mHandle, code, data, reply, flags);
        if (status == DEAD_OBJECT) mAlive = 0;
        return status;
    }

    return DEAD_OBJECT;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;IPCThreadState中写入数据到Binder设备过程&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;status_t IPCThreadState::transact(int32_t handle,
                                  uint32_t code, const Parcel&amp;amp; data,
                                  Parcel* reply, uint32_t flags)
{
    status_t err = data.errorCheck();

    flags |= TF_ACCEPT_FDS;

    ......    
      
    if (err != NO_ERROR) {
        if (reply) reply-&amp;gt;setError(err);
        return (mLastError = err);
    }
    
    if ((flags &amp;amp; TF_ONE_WAY) == 0) {
        #if 0
        if (code == 4) { // relayout
            ALOGI(&amp;quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; CALLING transaction 4&amp;quot;);
        } else {
            ALOGI(&amp;quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; CALLING transaction %d&amp;quot;, code);
        }
        #endif
        if (reply) {
            err = waitForResponse(reply);
        } else {
            Parcel fakeReply;
            err = waitForResponse(&amp;amp;fakeReply);
        }
        #if 0
        if (code == 4) { // relayout
            ALOGI(&amp;quot;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; RETURNING transaction 4&amp;quot;);
        } else {
            ALOGI(&amp;quot;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; RETURNING transaction %d&amp;quot;, code);
        }
        #endif
       } else {
        err = waitForResponse(NULL, NULL);
    }
    
    return err;
}

status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)
{
    while (1) {
        //将数据写入到Binder设备中
        talkWithDriver();
        ……
    }
    return err;
}
status_t IPCThreadState::talkWithDriver(bool doReceive)
{
    //将数据封装成binder_write_read结构
    binder_write_read bwr;

    do {
        //将数据写入到所打开的Binder设备中
        ioctl(mProcess-&amp;gt;mDriverFD, BINDER_WRITE_READ, &amp;amp;bwr)
        ……
    
    } while (err == -EINTR);
    return NO_ERROR;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将MediaPlayerService加入到ServiceManager中，
这里就通过BpServiceManager的AddService将数据写入到Binder设备传递给ServiceManager。&lt;/p&gt;

&lt;h2&gt;Media Process消息循环&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;int main(int argc, char** argv)
{
    //启动进程的线程池    
    ProcessState::self()-&amp;gt;startThreadPool();     //走到了这里

    //执行线程消息循环
    IPCThreadState::self()-&amp;gt;joinThreadPool();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ProcessState::self()-&gt;startThreadPool(); -----&gt; 创建工作者线程:
startThreadPool：\frameworks\native\libs\binder\ ProcessState.cpp：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;void ProcessState::spawnPooledThread(bool isMain)
{
    if (mThreadPoolStarted) {
        int32_t s = android_atomic_add(1, &amp;amp;mThreadPoolSeq);
        char buf[16];
        snprintf(buf, sizeof(buf), &amp;quot;Binder_%X&amp;quot;, s);
        ALOGV(&amp;quot;Spawning new pooled thread, name=%s\n&amp;quot;, buf);
//创建PoolThread对象 并run ，非线程
        sp&amp;lt;Thread&amp;gt; t = new PoolThread(isMain);
        t-&amp;gt;run(buf);
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;PoolThread继承Thread
执行Thread的run函数
位于utils/Threads.cpp&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;status_t Thread::run(const char* name, int32_t priority, size_t stack)
{
    //创建线程mThread _threadLoop
    bool res;
    res = createThreadEtc(_threadLoop,
    this, name, priority, stack, &amp;amp;mThread);

    return NO_ERROR;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在有两个线程：主线程和mThread线程
mThread线程执行：_threadLoop&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;int Thread::_threadLoop(void* user)
{
    Thread* const self = static_cast&amp;lt;Thread*&amp;gt;(user);
    do {
        //调用子类的threadLoop
        result = self-&amp;gt;threadLoop();
        ……
    } while(strong != 0);
    return 0;
}

class PoolThread : public Thread
{
protected:
    virtual bool threadLoop()
    {
        IPCThreadState::self()-&amp;gt;joinThreadPool(mIsMain);
        return false;
    }
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;进程间通信消息循环过程&lt;/h2&gt;

&lt;p&gt;消息循环:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;void IPCThreadState::joinThreadPool(bool isMain)
{
    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);
    status_t result;    
    //消息循环
    do {
        int32_t cmd;
        //从binder设备中读取命令
        result = talkWithDriver();
        if (result &amp;gt;= NO_ERROR) {
            cmd = mIn.readInt32();
            //执行命令
            result = executeCommand(cmd);
        }
           ……
    } while (result != -ECONNREFUSED &amp;amp;&amp;amp; result != -EBADF);
    
    mOut.writeInt32(BC_EXIT_LOOPER);
    talkWithDriver(false);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;命令执行：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;status_t IPCThreadState::executeCommand(int32_t cmd)
{
    BBinder* obj;
    RefBase::weakref_type* refs;
    switch (cmd) {
    case BR_DECREFS:
        break;
    case BR_ATTEMPT_ACQUIRE:
        break;
case BR_TRANSACTION:
　　binder_transaction_data tr;
    result = mIn.read(&amp;amp;tr, sizeof(tr));
      if (tr.target.ptr) {
        //将目标对象转化成BBinder
        sp&amp;lt;BBinder&amp;gt; b((BBinder*)tr.cookie);
        //调用BBinder的transact 函数
       const status_t error = b-&amp;gt;transact(tr.code, buffer, &amp;amp;reply, tr.flags);
      }
        break;
    ……
    default:
    }
    return result;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;binder_transaction_data.cookie：target object cookie目标对象，这个target object是指那个呢？&lt;/p&gt;

&lt;p&gt;在Media Process里面有几个Service：AudioFlinger、MediaPlayerService、CameraService等。&lt;/p&gt;

&lt;p&gt;这个目标是这其中Service中的一个，假设目标对象为为MediaPlayerService，那为何要转化成BBinder呢？&lt;/p&gt;

&lt;h2&gt;Service对命令的处理&lt;/h2&gt;

&lt;p&gt;线程从binder接收到消息命令，将命令传递给Service处理。将目标对象转化成BBinder，然后调度此命令；
命令从远端传递到本地端进行处理，每个Service都对应BnXXX对象来处理远端BpXXX传来的命令。
　　sp&lt;BBinder&gt; b((BBinder*)tr.cookie);
　　const status_t error = b-&gt;transact(tr.code, buffer, &amp;amp;reply, tr.flags);
　　这里b代表某个Service：假设为MediaPlayerService；弄清楚执行过程，要弄清楚类继承关系。&lt;/p&gt;

&lt;p&gt;本地端BnMediaPlayerService消息处理过程：真正的对象是MediaPlayerService实例。
从BBinder -&gt;transact开始传递：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;status_t BBinder::transact(
    uint32_t code, const Parcel&amp;amp; data, Parcel* reply, uint32_t flags)
{
    data.setDataPosition(0);

    status_t err = NO_ERROR;
    switch (code) {
        case PING_TRANSACTION:
            reply-&amp;gt;writeInt32(pingBinder());
            break;
        default:
        //onTransact是个virtual函数 派生类BnMediaPlayerService重写
            err = onTransact(code, data, reply, flags);
            break;
    }

    if (reply != NULL) {
        reply-&amp;gt;setDataPosition(0);
    }

    return err;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;调用的是onTransact(code, data, reply, flags); BBinder的onTransact是虚函数，被子类BnMediaPlayerService复写:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里调用的ProcessState的getContextObject;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;sp&amp;lt;IBinder&amp;gt; ProcessState::getContextObject(const sp&amp;lt;IBinder&amp;gt;&amp;amp; caller)
{
    return getStrongProxyForHandle(0);
}

    sp&amp;lt;IBinder&amp;gt; ProcessState::getStrongProxyForHandle(int32_t handle)
{
    sp&amp;lt;IBinder&amp;gt; result;

    AutoMutex _l(mLock);

    handle_entry* e = lookupHandleLocked(handle);

    if (e != NULL) {
        // We need to create a new BpBinder if there isn&amp;#39;t currently one, OR we
        // are unable to acquire a weak reference on this current one.  See comment
        // in getWeakProxyForHandle() for more info about this.
        IBinder* b = e-&amp;gt;binder;
        if (b == NULL || !e-&amp;gt;refs-&amp;gt;attemptIncWeak(this)) {
            b = new BpBinder(handle); 
            e-&amp;gt;binder = b;
            if (b) e-&amp;gt;refs = b-&amp;gt;getWeakRefs();
            result = b;
        } else {
            // This little bit of nastyness is to allow us to add a primary
            // reference to the remote proxy when this team doesn&amp;#39;t have one
            // but another team is sending the handle to us.
            result.force_set(b);
            e-&amp;gt;refs-&amp;gt;decWeak(this);
        }
    }

    return result;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在看看BpBinder：&lt;/p&gt;

&lt;h2&gt;BpBinder&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;BpBinder::BpBinder(int32_t handle)
    : mHandle(handle)
    , mAlive(1)
    , mObitsSent(0)
    , mObituaries(NULL)
{
    ALOGV(&amp;quot;Creating BpBinder %p handle %d\n&amp;quot;, this, mHandle);

    extendObjectLifetime(OBJECT_LIFETIME_WEAK);
    IPCThreadState::self()-&amp;gt;incWeakHandle(handle);//FT，竟然到IPCThreadState::self()
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里一块说说吧，IPCThreadState::self估计怎么着又是一个singleton吧？&lt;/p&gt;

&lt;p&gt;//该文件位置在framework\base\libs\binder\IPCThreadState.cpp&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;IPCThreadState* IPCThreadState::self()
{
    if (gHaveTLS) {
restart:
        const pthread_key_t k = gTLS;
//TLS是Thread Local Storage的意思，不懂得自己去google下它的作用吧。这里只需要

//知道这种空间每个线程有一个，而且线程间不共享这些空间，好处是？我就不用去搞什么

//同步了。在这个线程，我就用这个线程的东西，反正别的线程获取不到其他线程TLS中的数据。===》这句话有漏洞，钻牛角尖的明白大概意思就可以了。

//从线程本地存储空间中获得保存在其中的IPCThreadState对象

//这段代码写法很晦涩，看见没，只有pthread_getspecific,那么肯定有地方调用

// pthread_setspecific
        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);
        if (st) return st;
        return new IPCThreadState;
    }
    
    if (gShutdown) return NULL;
    
    pthread_mutex_lock(&amp;amp;gTLSMutex);
    if (!gHaveTLS) {
        if (pthread_key_create(&amp;amp;gTLS, threadDestructor) != 0) {
            pthread_mutex_unlock(&amp;amp;gTLSMutex);
            return NULL;
        }
        gHaveTLS = true;
    }
    pthread_mutex_unlock(&amp;amp;gTLSMutex);
    goto restart;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;构造函数:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;ul&gt;
    &lt;li&gt;jekyll打开本地服务jekyll serve&lt;/li&gt;
    &lt;li&gt;关于jekyll的 Address already in use - bind(2):&lt;/br&gt;
        先采用lsof -wni tcp:4000 或者使用 ps aux |grep &quot;jek&quot;&lt;/br&gt;
        再采用kill -9 PID命令
        &lt;/li&gt;
    
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/images/android/androidL_1.png&quot; title=&quot;Optional title&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;​http://developer.android.com/preview/api-overview.html&lt;/li&gt;
&lt;li&gt;​http://developer.android.com/preview/api-overview.html&lt;/li&gt;
&lt;li&gt;​http://developer.android.com/preview/api-overview.html&lt;/li&gt;
&lt;li&gt;​http://developer.android.com/preview/api-overview.html&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;结论&lt;/h3&gt;

&lt;p&gt;1.androd的底层实现是通过socket和共享内存的方式，这种写法也可以采用在我们自己的多进程通信上使用，值得学习
2.底层所有的event其实都是一样的，都是inputEvent，上层会根据source再分成keyEvent,MotionEvent等，用于不同的用处
3.所有View的起点其实就是dispatchPointerEvent()，这个是分发事件的起点.&lt;/p&gt;

&lt;h3&gt;参考blog&lt;/h3&gt;

&lt;p&gt;http://www.cnblogs.com/-OYK/archive/2011/07/31/2122981.html
http://www.cnblogs.com/zhangxinyan/p/3487905.html
http://blog.csdn.net/yangwen123/article/details/9142521
http://blog.csdn.net/maxleng/article/details/5490770
http://www.cnblogs.com/innost/archive/2011/01/09/1931456.html
http://www.cnblogs.com/bastard/archive/2012/11/13/2766611.html
http://blog.csdn.net/a220315410/article/details/17761681&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>关于android的Activity是如何触摸事件框架简析(二)</title>
     <link href="http://beiyuu.com/AndroidTouch1"/>
     <updated>2015-01-08T00:00:00+08:00</updated>
     <id>http://beiyuu.com/AndroidTouch1</id>
     <content type="html">&lt;p&gt;上次分析了touch事件如何传到我们的View上面了，这次分析下View是如何做分发的.
从最基本的View层次分析&lt;/p&gt;

&lt;h3&gt;View的事件分发&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;/**
     * Pass the touch screen motion event down to the target view, or this
     * view if it is the target.
     *
     * @param event The motion event to be dispatched.
     * @return True if the event was handled by the view, false otherwise.
     */
    public boolean dispatchTouchEvent(MotionEvent event) {
        if (mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onTouchEvent(event, 0);
        }

        if (onFilterTouchEventForSecurity(event)) {
            //noinspection SimplifiableIfStatement
            ListenerInfo li = mListenerInfo;
            if (li != null &amp;amp;&amp;amp; li.mOnTouchListener != null &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED
                    &amp;amp;&amp;amp; li.mOnTouchListener.onTouch(this, event)) {
                return true;
            }

            if (onTouchEvent(event)) {
                return true;
            }
        }

        if (mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
        }
        return false;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最先调用的是onTouch事件,如果onTouch返回True,则直接返回了,在分析下onTouchEvent发生了什么事情:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;/**
     * Implement this method to handle touch screen motion events.
     *
     * @param event The motion event.
     * @return True if the event was handled, false otherwise.
     */
    public boolean onTouchEvent(MotionEvent event) {
        final int viewFlags = mViewFlags;

        if ((viewFlags &amp;amp; ENABLED_MASK) == DISABLED) {
            if (event.getAction() == MotionEvent.ACTION_UP &amp;amp;&amp;amp; (mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0) {
                setPressed(false);
            }
            // A disabled view that is clickable still consumes the touch
            // events, it just doesn&amp;#39;t respond to them.
            return (((viewFlags &amp;amp; CLICKABLE) == CLICKABLE ||
                    (viewFlags &amp;amp; LONG_CLICKABLE) == LONG_CLICKABLE));
        }
        if (mTouchDelegate != null) {
            if (mTouchDelegate.onTouchEvent(event)) {
                return true;
            }
        }
        if (((viewFlags &amp;amp; CLICKABLE) == CLICKABLE ||
                (viewFlags &amp;amp; LONG_CLICKABLE) == LONG_CLICKABLE)) {
            switch (event.getAction()) {
                case MotionEvent.ACTION_UP:
                    boolean prepressed = (mPrivateFlags &amp;amp; PFLAG_PREPRESSED) != 0;
                    if ((mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0 || prepressed) {
                        // take focus if we don&amp;#39;t have it already and we should in
                        // touch mode.
                        boolean focusTaken = false;
                        if (isFocusable() &amp;amp;&amp;amp; isFocusableInTouchMode() &amp;amp;&amp;amp; !isFocused()) {
                            focusTaken = requestFocus();
                        }

                        if (prepressed) {
                            // The button is being released before we actually
                            // showed it as pressed.  Make it show the pressed
                            // state now (before scheduling the click) to ensure
                            // the user sees it.
                            setPressed(true);
                       }

                        if (!mHasPerformedLongPress) {
                            // This is a tap, so remove the longpress check
                            removeLongPressCallback();

                            // Only perform take click actions if we were in the pressed state
                            if (!focusTaken) {
                                // Use a Runnable and post this rather than calling
                                // performClick directly. This lets other visual state
                                // of the view update before click actions start.
                                if (mPerformClick == null) {
                                    mPerformClick = new PerformClick();
                                }
                                if (!post(mPerformClick)) {
                                    performClick();
                                }
                            }
                        }

                        if (mUnsetPressedState == null) {
                            mUnsetPressedState = new UnsetPressedState();
                        }

                        if (prepressed) {
                            postDelayed(mUnsetPressedState,
                                    ViewConfiguration.getPressedStateDuration());
                        } else if (!post(mUnsetPressedState)) {
                            // If the post failed, unpress right now
                            mUnsetPressedState.run();
                        }
                        removeTapCallback();
                    }
                    break;

                case MotionEvent.ACTION_DOWN:
                    mHasPerformedLongPress = false;

                    if (performButtonActionOnTouchDown(event)) {
                        break;
                    }

                    // Walk up the hierarchy to determine if we&amp;#39;re inside a scrolling container.
                    boolean isInScrollingContainer = isInScrollingContainer();

                    // For views inside a scrolling container, delay the pressed feedback for
                    // a short period in case this is a scroll.
                    if (isInScrollingContainer) {
                        mPrivateFlags |= PFLAG_PREPRESSED;
                        if (mPendingCheckForTap == null) {
                            mPendingCheckForTap = new CheckForTap();
                        }
                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                    } else {
                        // Not inside a scrolling container, so show the feedback right away
                        setPressed(true);
                        checkForLongClick(0);
                    }
                    break;

                case MotionEvent.ACTION_CANCEL:
                    setPressed(false);
                    removeTapCallback();
                    removeLongPressCallback();
                    break;

                case MotionEvent.ACTION_MOVE:
                    final int x = (int) event.getX();
                    final int y = (int) event.getY();

                    // Be lenient about moving outside of buttons
                    if (!pointInView(x, y, mTouchSlop)) {
                        // Outside button
                        removeTapCallback();
                        if ((mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0) {
                            // Remove any future long press/tap checks
                            removeLongPressCallback();

                            setPressed(false);
                        }
                    }
                    break;
            }
            return true;
        }

        return false;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里值得注意的就是两个点:
1. onclick事件是在MotionEvent.ACTION_UP的时候返回的，是在onTouch事件之后
2. onTouchEvent返回值为True，才能接受到以后的事件，如果返回false则收不到。&lt;/p&gt;

&lt;h3&gt;ViewGroup的事件分发&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;/**
     * {@inheritDoc}
     */
    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
        }

        boolean handled = false;
        if (onFilterTouchEventForSecurity(ev)) {
            final int action = ev.getAction();
            final int actionMasked = action &amp;amp; MotionEvent.ACTION_MASK;

            // Handle an initial down.
            if (actionMasked == MotionEvent.ACTION_DOWN) {
                // Throw away all previous state when starting a new touch gesture.
                // The framework may have dropped the up or cancel event for the previous gesture
                // due to an app switch, ANR, or some other state change.
                cancelAndClearTouchTargets(ev);
                resetTouchState();
            }

            // Check for interception.
            final boolean intercepted;
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
                final boolean disallowIntercept = (mGroupFlags &amp;amp; FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
            }

            // Check for cancelation.
            final boolean canceled = resetCancelNextUpFlag(this)
                    || actionMasked == MotionEvent.ACTION_CANCEL;

            // Update list of touch targets for pointer down, if needed.
            final boolean split = (mGroupFlags &amp;amp; FLAG_SPLIT_MOTION_EVENTS) != 0;
            TouchTarget newTouchTarget = null;
            boolean alreadyDispatchedToNewTouchTarget = false;
            if (!canceled &amp;amp;&amp;amp; !intercepted) {
                if (actionMasked == MotionEvent.ACTION_DOWN
                        || (split &amp;amp;&amp;amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                    final int actionIndex = ev.getActionIndex(); // always 0 for down
                    final int idBitsToAssign = split ? 1 &amp;lt;&amp;lt; ev.getPointerId(actionIndex)
                            : TouchTarget.ALL_POINTER_IDS;

                    // Clean up earlier touch targets for this pointer id in case they
                    // have become out of sync.
                    removePointersFromTouchTargets(idBitsToAssign);

                    final int childrenCount = mChildrenCount;
                    if (childrenCount != 0) {
                        // Find a child that can receive the event.
                        // Scan children from front to back.
                        final View[] children = mChildren;
                        final float x = ev.getX(actionIndex);
                        final float y = ev.getY(actionIndex);

                        final boolean customOrder = isChildrenDrawingOrderEnabled();
                        for (int i = childrenCount - 1; i &amp;gt;= 0; i--) {
                            final int childIndex = customOrder ?
                                    getChildDrawingOrder(childrenCount, i) : i;
                            final View child = children[childIndex];
                            if (!canViewReceivePointerEvents(child)
                                    || !isTransformedTouchPointInView(x, y, child, null)) {
                                continue;
                            }

                            newTouchTarget = getTouchTarget(child);
                            if (newTouchTarget != null) {
                                // Child is already receiving touch within its bounds.
                                // Give it the new pointer in addition to the ones it is handling.
                                newTouchTarget.pointerIdBits |= idBitsToAssign;
                                break;
                            }

                            resetCancelNextUpFlag(child);
                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                // Child wants to receive touch within its bounds.
                                mLastTouchDownTime = ev.getDownTime();
                                mLastTouchDownIndex = childIndex;
                                mLastTouchDownX = ev.getX();
                                mLastTouchDownY = ev.getY();
                                newTouchTarget = addTouchTarget(child, idBitsToAssign);
                                alreadyDispatchedToNewTouchTarget = true;
                                break;
                            }
                        }
                    }

                    if (newTouchTarget == null &amp;amp;&amp;amp; mFirstTouchTarget != null) {
                        // Did not find a child to receive the event.
                        // Assign the pointer to the least recently added target.
                        newTouchTarget = mFirstTouchTarget;
                        while (newTouchTarget.next != null) {
                            newTouchTarget = newTouchTarget.next;
                        }
                        newTouchTarget.pointerIdBits |= idBitsToAssign;
                    }
                }
            }

            // Dispatch to touch targets.
            if (mFirstTouchTarget == null) {
                // No touch targets so treat this as an ordinary view.
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
            } else {
                // Dispatch to touch targets, excluding the new touch target if we already
                // dispatched to it.  Cancel touch targets if necessary.
                TouchTarget predecessor = null;
                TouchTarget target = mFirstTouchTarget;
                while (target != null) {
                    final TouchTarget next = target.next;
                    if (alreadyDispatchedToNewTouchTarget &amp;amp;&amp;amp; target == newTouchTarget) {
                        handled = true;
                    } else {
                        final boolean cancelChild = resetCancelNextUpFlag(target.child)
                        || intercepted;
                        if (dispatchTransformedTouchEvent(ev, cancelChild,
                                target.child, target.pointerIdBits)) {
                            handled = true;
                        }
                        if (cancelChild) {
                            if (predecessor == null) {
                                mFirstTouchTarget = next;
                            } else {
                                predecessor.next = next;
                            }
                            target.recycle();
                            target = next;
                            continue;
                        }
                    }
                    predecessor = target;
                    target = next;
                }
            }

            // Update list of touch targets for pointer up or cancel, if needed.
            if (canceled
                    || actionMasked == MotionEvent.ACTION_UP
                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                resetTouchState();
            } else if (split &amp;amp;&amp;amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {
                final int actionIndex = ev.getActionIndex();
                final int idBitsToRemove = 1 &amp;lt;&amp;lt; ev.getPointerId(actionIndex);
                removePointersFromTouchTargets(idBitsToRemove);
            }
        }

        if (!handled &amp;amp;&amp;amp; mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
        }
        return handled;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;代码很长，但是阅读完我们可以发现几点问题:
1.允许ViewGroup去做事件拦截通过方法onInterceptTouchEvent()，使用requestDisallowInterceptTouchEvent方法可以设置是否允许拦截touch事件。
2.onInterceptTouchEvent返回false的时候，会对事件进行分发，分发到子View上面。如果是某个子View是target,则调用子View的DdispatchTouchEvent，否则调用自身的super.dispatchTouchEvent方法。&lt;/p&gt;

&lt;h3&gt;Activity的事件分发&lt;/h3&gt;

&lt;p&gt;之前的文章就很明显的告诉我们ViewRootImpl会调用设置的mView，那么mView到底是什么呢？
回顾Activity代码:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;/**
     * Set the activity content from a layout resource.  The resource will be
     * inflated, adding all top-level views to the activity.
     *
     * @param layoutResID Resource ID to be inflated.
     * 
     * @see #setContentView(android.view.View)
     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
     */
    public void setContentView(int layoutResID) {
        getWindow().setContentView(layoutResID);
        initActionBar();
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里getWindow获取的是PhoneWindow的实例，其setContentView如下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Override
    public void setContentView(int layoutResID) {
        if (mContentParent == null) {
            installDecor();
        } else {
            mContentParent.removeAllViews();
        }
        mLayoutInflater.inflate(layoutResID, mContentParent);
        final Callback cb = getCallback();
        if (cb != null &amp;amp;&amp;amp; !isDestroyed()) {
            cb.onContentChanged();
        }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到传入的布局文件最终会展开并作为mContentParent的子View。那么mContentParent又是怎么产生的？看下installDecor方法：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;private void installDecor() {
        if (mDecor == null) {
            mDecor = generateDecor();
            mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
            mDecor.setIsRootNamespace(true);
            if (!mInvalidatePanelMenuPosted &amp;amp;&amp;amp; mInvalidatePanelMenuFeatures != 0) {
                mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);
            }
        }
        if (mContentParent == null) {
            mContentParent = generateLayout(mDecor);

            // Set up decor part of UI to ignore fitsSystemWindows if appropriate.
            mDecor.makeOptionalFitsSystemWindows();
            .......
        }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里通过generateLayout 创建了mContentParent，这个generateLayout是干嘛的呢？&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;protected ViewGroup generateLayout(DecorView decor) {
            ......
    // Inflate the window decor.

        int layoutResource;
        int features = getLocalFeatures();
        ......
        mDecor.startChanging();

        View in = mLayoutInflater.inflate(layoutResource, null);
        decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));

        ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
        if (contentParent == null) {
            throw new RuntimeException(&amp;quot;Window couldn&amp;#39;t find content container view&amp;quot;);
        }

        if ((features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_INDETERMINATE_PROGRESS)) != 0) {
            ProgressBar progress = getCircularProgressBar(false);
            if (progress != null) {
                progress.setIndeterminate(true);
            }
        }

        .........
        mDecor.finishChanging();
        return contentParent;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看出，Activity中，最上层为DecorView，mContentParent为DecorView中id为Window.ID_ANDROID_CONTENT的子View，而我们通过setContentView方法传入的布局文件则是mContentParent的子View。所以之前看过的mView，其实就是DecorView的一个实例，看下DecorView的dispatchTouchEvent:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Override
        public boolean dispatchKeyEvent(KeyEvent event) {
            if (!isDestroyed()) {
                final Callback cb = getCallback();
                final boolean handled = cb != null &amp;amp;&amp;amp; mFeatureId &amp;lt; 0 ? cb.dispatchKeyEvent(event)
                        : super.dispatchKeyEvent(event);
                if (handled) {
                    return true;
                }
            }

            return isDown ? PhoneWindow.this.onKeyDown(mFeatureId, event.getKeyCode(), event)
                    : PhoneWindow.this.onKeyUp(mFeatureId, event.getKeyCode(), event);
        }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的callback就是Activity，所以调用的就是Activity的dispatchKeyEvent().&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;/**
     * Called to process touch screen events.  You can override this to
     * intercept all touch screen events before they are dispatched to the
     * window.  Be sure to call this implementation for touch screen events
     * that should be handled normally.
     * 
     * @param ev The touch screen event.
     * 
     * @return boolean Return true if this event was consumed.
     */
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();
        }
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        return onTouchEvent(ev);
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;先调用的DecorView的superDispatchTouchEvent：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public boolean superDispatchTouchEvent(MotionEvent event) {
            return super.dispatchTouchEvent(event);
        }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里就算分析完了，DecorView其实就是一个FrameLayout。&lt;/p&gt;

&lt;h3&gt;结论&lt;/h3&gt;

&lt;p&gt;1.我们可以发现大体的顺序是这样的 Activity  ----&gt;  ViewGroup  ----&gt;  View 通过这样的模型进行消息分发的。
2. onTouch事件都是在 onTouchEvent之前的 设置为True了 事件就不会往下传。
3.修改onTouchEvent事件的返回值可能对下次的事件有影响，改为false可能以后都收不到了。&lt;/p&gt;

&lt;h3&gt;参考blog&lt;/h3&gt;
</content>
   </entry>
   
   <entry>
     <title>关于android的Activity是如何触摸事件框架简析(一)</title>
     <link href="http://beiyuu.com/AndroidTouch"/>
     <updated>2015-01-06T00:00:00+08:00</updated>
     <id>http://beiyuu.com/AndroidTouch</id>
     <content type="html">&lt;p&gt;最近做项目会修改导事件分发，所以对系统这部分代码进行了一定的研究，对android的框架的流的过程发出来供大家参考下.
所有代码研究基于android4.2.2_R1&lt;/p&gt;

&lt;h3&gt;Activity与windowMnager打交道的过程&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;首先是我们如何开启一个ActivityThread的，在ActivityThread中我们做了什么:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在ActivityThread中会最先调用的是handleLaunchActivity--&gt;handleResumeActivity;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward,
            boolean reallyResume) {
        .......
        if (r.window == null &amp;amp;&amp;amp; !a.mFinished &amp;amp;&amp;amp; willBeVisible) {
                r.window = r.activity.getWindow();
                View decor = r.window.getDecorView();
                decor.setVisibility(View.INVISIBLE);
                ViewManager wm = a.getWindowManager();
                WindowManager.LayoutParams l = r.window.getAttributes();
                a.mDecor = decor;
                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
                l.softInputMode |= forwardBit;
                if (a.mVisibleFromClient) {
                    a.mWindowAdded = true;
                    wm.addView(decor, l);
                }
        ......

    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;核心代码就是上面的通过windowManager添加View,
这里的wm实体其实是&lt;em&gt;WindowMnagerGlobal&lt;/em&gt;,查看addView:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
        
        ......
        ViewRootImpl root;
        View panelParentView = null;
        root = new ViewRootImpl(view.getContext(), display);
        view.setLayoutParams(wparams);
        ......
        // do this last because it fires off messages to start doing things
        try {
            root.setView(view, wparams, panelParentView);
        } catch (RuntimeException e) {
            // BadTokenException or InvalidDisplayException, clean up.
            synchronized (mLock) {
                final int index = findViewLocked(view, false);
                if (index &amp;gt;= 0) {
                    removeViewLocked(index, true);
                }
            }
            throw e;
        }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里是new出了一个新的ViewRootImpl调用了setView方法:
ViewRootImpl.java&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;/**
     * We have one child
     */
    public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
            ......
            try {
                    mOrigWindowType = mWindowAttributes.type;
                    mAttachInfo.mRecomputeGlobalAttributes = true;
                    collectViewAttributes();
                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mInputChannel);
                } catch (RemoteException e) {
                    mAdded = false;
                    mView = null;
                    mAttachInfo.mRootView = null;
                    mInputChannel = null;
                    mFallbackEventHandler.setView(null);
                    unscheduleTraversals();
                    setAccessibilityFocus(null, null);
                    throw new RuntimeException(&amp;quot;Adding window failed&amp;quot;, e);
                } finally {
                    if (restore) {
                        attrs.restore();
                    }
                }
            .......
            if (mInputChannel != null) {
                    if (mInputQueueCallback != null) {
                        mInputQueue = new InputQueue(mInputChannel);
                        mInputQueueCallback.onInputQueueCreated(mInputQueue);
                    } else {
                        mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,
                                Looper.myLooper());
                    }
                }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;核心代码就是 mWindowSession.addToDisplay(),&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Override
    public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,
            int viewVisibility, int displayId, Rect outContentInsets,
            InputChannel outInputChannel) {
        return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,
                outContentInsets, outInputChannel);
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就是一个aidl调用，最终是调用的WindowManagerService的addWindow方法：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public int addWindow(Session session, IWindow client, int seq,
            WindowManager.LayoutParams attrs, int viewVisibility, int displayId,
            Rect outContentInsets, InputChannel outInputChannel) {

        ......
        if (outInputChannel != null &amp;amp;&amp;amp; (attrs.inputFeatures
                    &amp;amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
                String name = win.makeInputChannelName();
                InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);
                win.setInputChannel(inputChannels[0]);
                inputChannels[1].transferTo(outInputChannel);

                mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);
            }
        ......
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里打开了一对inputChannel一个作为server端，一个作为client端，并且注册到inputManager里头.这个inputChannel其实就是pipe,我们看看他们是怎么生成的：
inputChannel.java&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;/**
     * Creates a new input channel pair.  One channel should be provided to the input
     * dispatcher and the other to the application&amp;#39;s input queue.
     * @param name The descriptive (non-unique) name of the channel pair.
     * @return A pair of input channels.  They are symmetric and indistinguishable.
     */
    public static InputChannel[] openInputChannelPair(String name) {
        if (name == null) {
            throw new IllegalArgumentException(&amp;quot;name must not be null&amp;quot;);
        }

        if (DEBUG) {
            Slog.d(TAG, &amp;quot;Opening input channel pair &amp;#39;&amp;quot; + name + &amp;quot;&amp;#39;&amp;quot;);
        }
        return nativeOpenInputChannelPair(name);
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;natvie层对应代码：
android_view_inputchannel.cpp&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;static jobjectArray android_view_InputChannel_nativeOpenInputChannelPair(JNIEnv* env,
        jclass clazz, jstring nameObj) {
    const char* nameChars = env-&amp;gt;GetStringUTFChars(nameObj, NULL);
    String8 name(nameChars);
    env-&amp;gt;ReleaseStringUTFChars(nameObj, nameChars);

    sp&amp;lt;InputChannel&amp;gt; serverChannel;
    sp&amp;lt;InputChannel&amp;gt; clientChannel;
    status_t result = InputChannel::openInputChannelPair(name, serverChannel, clientChannel);

    if (result) {
        String8 message;
        message.appendFormat(&amp;quot;Could not open input channel pair.  status=%d&amp;quot;, result);
        jniThrowRuntimeException(env, message.string());
        return NULL;
    }

    jobjectArray channelPair = env-&amp;gt;NewObjectArray(2, gInputChannelClassInfo.clazz, NULL);
    if (env-&amp;gt;ExceptionCheck()) {
        return NULL;
    }

    jobject serverChannelObj = android_view_InputChannel_createInputChannel(env,
            new NativeInputChannel(serverChannel));
    if (env-&amp;gt;ExceptionCheck()) {
        return NULL;
    }

    jobject clientChannelObj = android_view_InputChannel_createInputChannel(env,
            new NativeInputChannel(clientChannel));
    if (env-&amp;gt;ExceptionCheck()) {
        return NULL;
    }

    env-&amp;gt;SetObjectArrayElement(channelPair, 0, serverChannelObj);
    env-&amp;gt;SetObjectArrayElement(channelPair, 1, clientChannelObj);
    return channelPair;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;主要关注函数openInputChannelPair&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;status_t InputChannel::openInputChannelPair(const String8&amp;amp; name,
        sp&amp;lt;InputChannel&amp;gt;&amp;amp; outServerChannel, sp&amp;lt;InputChannel&amp;gt;&amp;amp; outClientChannel) {
    int sockets[2];
    if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets)) {
        status_t result = -errno;
        ALOGE(&amp;quot;channel &amp;#39;%s&amp;#39; ~ Could not create socket pair.  errno=%d&amp;quot;,
                name.string(), errno);
        outServerChannel.clear();
        outClientChannel.clear();
        return result;
    }

    int bufferSize = SOCKET_BUFFER_SIZE;
    setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &amp;amp;bufferSize, sizeof(bufferSize));
    setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &amp;amp;bufferSize, sizeof(bufferSize));
    setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &amp;amp;bufferSize, sizeof(bufferSize));
    setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &amp;amp;bufferSize, sizeof(bufferSize));

    String8 serverChannelName = name;
    serverChannelName.append(&amp;quot; (server)&amp;quot;);
    outServerChannel = new InputChannel(serverChannelName, sockets[0]);

    String8 clientChannelName = name;
    clientChannelName.append(&amp;quot; (client)&amp;quot;);
    outClientChannel = new InputChannel(clientChannelName, sockets[1]);
    return OK;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里就可以发现双方是通过一个共享内存，socket的方式通信。这时候我们就已经初步的了解 Activity与windowManagerService是如何建立联系的.&lt;/p&gt;

&lt;h3&gt;Activity接收事件过程&lt;/h3&gt;

&lt;p&gt;在ViewRootImpl中，我们会创建一个WindowInputEventReceiver，WindowInputEventReceiver的初始化会使用inputchannel和主线程的looper,继承于InputEventReceiver:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;**
     * Creates an input event receiver bound to the specified input channel.
     *
     * @param inputChannel The input channel.
     * @param looper The looper to use when invoking callbacks.
     */
    public InputEventReceiver(InputChannel inputChannel, Looper looper) {
        if (inputChannel == null) {
            throw new IllegalArgumentException(&amp;quot;inputChannel must not be null&amp;quot;);
        }
        if (looper == null) {
            throw new IllegalArgumentException(&amp;quot;looper must not be null&amp;quot;);
        }

        mInputChannel = inputChannel;
        mMessageQueue = looper.getQueue();
        mReceiverPtr = nativeInit(this, inputChannel, mMessageQueue);

        mCloseGuard.open(&amp;quot;dispose&amp;quot;);
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;会调用底层的nativeInit：
android_view_InputEventReceiver.cpp&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;static jint nativeInit(JNIEnv* env, jclass clazz, jobject receiverObj,
        jobject inputChannelObj, jobject messageQueueObj) {
    sp&amp;lt;InputChannel&amp;gt; inputChannel = android_view_InputChannel_getInputChannel(env,
            inputChannelObj);
    if (inputChannel == NULL) {
        jniThrowRuntimeException(env, &amp;quot;InputChannel is not initialized.&amp;quot;);
        return 0;
    }

    sp&amp;lt;MessageQueue&amp;gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);
    if (messageQueue == NULL) {
        jniThrowRuntimeException(env, &amp;quot;MessageQueue is not initialized.&amp;quot;);
        return 0;
    }

    sp&amp;lt;NativeInputEventReceiver&amp;gt; receiver = new NativeInputEventReceiver(env,
            receiverObj, inputChannel, messageQueue);
    status_t status = receiver-&amp;gt;initialize();
    if (status) {
        String8 message;
        message.appendFormat(&amp;quot;Failed to initialize input event receiver.  status=%d&amp;quot;, status);
        jniThrowRuntimeException(env, message.string());
        return 0;
    }

    receiver-&amp;gt;incStrong(gInputEventReceiverClassInfo.clazz); // retain a reference for the object
    return reinterpret_cast&amp;lt;jint&amp;gt;(receiver.get());
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里其实是拿到上层的looper和上层的inputchannel去生成一个NativeInputEventReceiver，在看看NativeInputEventReceiver的作用:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;NativeInputEventReceiver::NativeInputEventReceiver(JNIEnv* env,
        jobject receiverObj, const sp&amp;lt;InputChannel&amp;gt;&amp;amp; inputChannel,
        const sp&amp;lt;MessageQueue&amp;gt;&amp;amp; messageQueue) :
        mReceiverObjGlobal(env-&amp;gt;NewGlobalRef(receiverObj)),
        mInputConsumer(inputChannel), mMessageQueue(messageQueue),
        mBatchedInputEventPending(false) {
#if DEBUG_DISPATCH_CYCLE
    ALOGD(&amp;quot;channel &amp;#39;%s&amp;#39; ~ Initializing input event receiver.&amp;quot;, getInputChannelName());
#endif
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;status_t NativeInputEventReceiver::initialize() {
    int receiveFd = mInputConsumer.getChannel()-&amp;gt;getFd();
    mMessageQueue-&amp;gt;getLooper()-&amp;gt;addFd(receiveFd, 0, ALOOPER_EVENT_INPUT, this, NULL);
    return OK;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;NativeInputEventReceiver实际上就是生成了一个mInputConsumer,并且调用initialize，将inputChannel的fd挂载到looper中去监听事件，回调函数为handleEvent：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;int NativeInputEventReceiver::handleEvent(int receiveFd, int events, void* data) {
    if (events &amp;amp; (ALOOPER_EVENT_ERROR | ALOOPER_EVENT_HANGUP)) {
        ALOGE(&amp;quot;channel &amp;#39;%s&amp;#39; ~ Publisher closed input channel or an error occurred.  &amp;quot;
                &amp;quot;events=0x%x&amp;quot;, getInputChannelName(), events);
        return 0; // remove the callback
    }

    if (!(events &amp;amp; ALOOPER_EVENT_INPUT)) {
        ALOGW(&amp;quot;channel &amp;#39;%s&amp;#39; ~ Received spurious callback for unhandled poll event.  &amp;quot;
                &amp;quot;events=0x%x&amp;quot;, getInputChannelName(), events);
        return 1;
    }

    JNIEnv* env = AndroidRuntime::getJNIEnv();
    status_t status = consumeEvents(env, false /*consumeBatches*/, -1);
    mMessageQueue-&amp;gt;raiseAndClearException(env, &amp;quot;handleReceiveCallback&amp;quot;);
    return status == OK || status == NO_MEMORY ? 1 : 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env,
        bool consumeBatches, nsecs_t frameTime) {
    .......
        if (!skipCallbacks) {
            jobject inputEventObj;
            switch (inputEvent-&amp;gt;getType()) {
            case AINPUT_EVENT_TYPE_KEY:
#if DEBUG_DISPATCH_CYCLE
                ALOGD(&amp;quot;channel &amp;#39;%s&amp;#39; ~ Received key event.&amp;quot;, getInputChannelName());
#endif
                inputEventObj = android_view_KeyEvent_fromNative(env,
                        static_cast&amp;lt;KeyEvent*&amp;gt;(inputEvent));
                break;

            case AINPUT_EVENT_TYPE_MOTION:
#if DEBUG_DISPATCH_CYCLE
                ALOGD(&amp;quot;channel &amp;#39;%s&amp;#39; ~ Received motion event.&amp;quot;, getInputChannelName());
#endif
                inputEventObj = android_view_MotionEvent_obtainAsCopy(env,
                        static_cast&amp;lt;MotionEvent*&amp;gt;(inputEvent));
                break;

            default:
                assert(false); // InputConsumer should prevent this from ever happening
                inputEventObj = NULL;
            }

            if (inputEventObj) {
#if DEBUG_DISPATCH_CYCLE
                ALOGD(&amp;quot;channel &amp;#39;%s&amp;#39; ~ Dispatching input event.&amp;quot;, getInputChannelName());
#endif
                env-&amp;gt;CallVoidMethod(mReceiverObjGlobal,
                        gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj);
                if (env-&amp;gt;ExceptionCheck()) {
                    ALOGE(&amp;quot;Exception dispatching input event.&amp;quot;);
                    skipCallbacks = true;
                }
            } else {
                ALOGW(&amp;quot;channel &amp;#39;%s&amp;#39; ~ Failed to obtain event object.&amp;quot;, getInputChannelName());
                skipCallbacks = true;
            }
        }

        if (skipCallbacks) {
            mInputConsumer.sendFinishedSignal(seq, false);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里会回调到java层上的InputEventReceiver的dispatchInputEvent：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;// Called from native code.
    @SuppressWarnings(&amp;quot;unused&amp;quot;)
    private void dispatchInputEvent(int seq, InputEvent event) {
        mSeqMap.put(event.getSequenceNumber(), seq);
        onInputEvent(event);
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的onInputEvent(event)方法已经被WindowInputEventReceiver复写了:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Override
        public void onInputEvent(InputEvent event) {
            enqueueInputEvent(event, this, 0, true);
        }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里往下翻一点就知道这个队列做了什么事情:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;private void deliverInputEvent(QueuedInputEvent q) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &amp;quot;deliverInputEvent&amp;quot;);
        try {
            if (q.mEvent instanceof KeyEvent) {
                deliverKeyEvent(q);
            } else {
                final int source = q.mEvent.getSource();
                if ((source &amp;amp; InputDevice.SOURCE_CLASS_POINTER) != 0) {
                    deliverPointerEvent(q);
                } else if ((source &amp;amp; InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
                    deliverTrackballEvent(q);
                } else {
                    deliverGenericMotionEvent(q);
                }
            }
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里讲底层的inputEvent分成各种不同的类型去区别对待.&lt;/p&gt;

&lt;p&gt;这里就能看到View是如何接收事件的整个过程的&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;结论&lt;/h3&gt;

&lt;p&gt;1.androd的底层实现是通过socket和共享内存的方式，这种写法也可以采用在我们自己的多进程通信上使用，值得学习
2.底层所有的event其实都是一样的，都是inputEvent，上层会根据source再分成keyEvent,MotionEvent等，用于不同的用处
3.所有View的起点其实就是dispatchPointerEvent()，这个是分发事件的起点.&lt;/p&gt;

&lt;h3&gt;参考blog&lt;/h3&gt;
</content>
   </entry>
   
   <entry>
     <title>Android图形的知识</title>
     <link href="http://beiyuu.com/AndroidCanvas"/>
     <updated>2014-12-13T00:00:00+08:00</updated>
     <id>http://beiyuu.com/AndroidCanvas</id>
     <content type="html">&lt;h3&gt;关于自定义控件的基础知识&lt;/h3&gt;

&lt;p&gt;自定义控件的一个重点就是实现就是去重写他的绘制过程,也就是View.onDraw(Canvas canvas)方法。这个里面就是绘制图形的过程了，比如说一个Button，绘制按钮和按钮上的文字都是在它自己的onDraw方法中完成的。如果你想给ImageView加个蒙版，可以继承ImageView并且重写他的onDraw方法，调用完父类的onDraw之后，再自己Canvas来画一个黑色的半透明矩形，这样就可以对现有的控件进行加工了。
Canvas是什么呢？是画布，你绘制东西的时候就是绘到了这个画布上，给用户显示的东西也是这个画布上的东西。通常来说，当你调用到onDraw方法的时候对应的View已经确定了他的宽度和高度(关于View的measure和layout过程以后再详述)。那么在Canvas上，你画的范围就只有View对应的大小了。我们用代码来描述下&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    int verticalCenter    =  getHeight() / 2;
    int horizontalCenter  =  getWidth() / 2;
    int circleRadius      = 200;
    Paint paint = new Paint();
    paint.setAntiAlias(false);
    paint.setColor(Color.RED);
    canvas.drawCircle( horizontalCenter, verticalCenter-250, circleRadius, paint);

    paint.setAntiAlias(true);
    paint.setStyle(Paint.Style.STROKE);
    paint.setStrokeWidth(20);
    canvas.drawCircle( horizontalCenter, verticalCenter+250, circleRadius, paint);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个View的大小可以通过getHeight()和getWidth()来获得。我们准备画两个圆圈，半径都是200。我们主要用到的方法是drawCircle()方法，参数的意义分别是圆心的x，y坐标，半径和所使用的画笔Paint。&lt;/p&gt;

&lt;p&gt;Paint是什么？是画笔的意思，Canvas是画布，Paint是画笔，画笔控制了所画东西的颜色大小字体等等。在画第一个圆的时候，我们通过Paint.setAntiAlias方法设置抗锯齿属性为false，并设置颜色为红色。&lt;/p&gt;

&lt;p&gt;在画第二个圆的时候，我们打开了抗锯齿。将Paint的风格设为STROKE，也就是只画边框。然后设置边框宽度为20.&lt;/p&gt;

&lt;h3&gt;关于Canvas所涉及的到的类&lt;/h3&gt;

&lt;p&gt;android.graphics.* 包里面主要由以下一些类：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;Canvas/li&gt;
    &lt;li&gt;Bitmap及其相关的类&lt;/li&gt;
    &lt;li&gt;Xfermode及其子类&lt;/li&gt;
    &lt;li&gt;Paint及其相关类和内部类&lt;/li&gt;
    &lt;li&gt;Shader及其子类&lt;/li&gt;
    &lt;li&gt;Rect，Color，Point，Path等基础类&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Canvas.drawText绘制文字为什么会偏上？&lt;/h3&gt;

&lt;p&gt;如果你经常使用Canvas的draw***方法去绘制一些图像图形，你会知道绘制的时候坐标是从Canvas左上角开始计算的，如果想要把一个图像放到某个位置，直接drawBitmap传递图片左上角的坐标就行了.&lt;/p&gt;

&lt;p&gt;那drawText就不一样了，如果你传递进去字符串，会发现文字的位置和你指定的不一样。&lt;/p&gt;

&lt;p&gt;卧槽为啥。Android的文档也没有仔细说，打开源码一看，又跑到native代码里去执行了。经过我奋力地Google，终于把这个问题搞清楚了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android/android_drawtext.jpeg&quot; title=&quot;Optional title&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于一段文字来说，如果你想把他画到Canvas上，首先你要确定这段文字的范围，即宽度和高度，那么怎么去取这一段的高度呢，如果你在网上搜，会有很多种答案，具体应该用哪一种呢？这要看你到底需要什么样的尺寸了。&lt;/p&gt;

&lt;p&gt;Paint.getTextBounds: 当你通过这个方法来获取尺寸的时候，你可以得到能够包裹文字的最小矩形，就是图中红色边框的那部分，你可以得到一个Rect对象，包含这个最小尺寸的几个值。坑其实就在这里：这里的Rect对象坐标并不是以左上角为准的，而是相对于左边中间靠下位置的一个点，就是图中的黄色五角星。而这里水平的Baseline指的是字符串对齐的一条线（真正的含义可以需要更深入了解字体渲染的知识了）。既然这样，r.top就是一个负值了，r.bottom会是一个小一点的正值，r.left和r.right在图中画的都很清楚。通过r.width()和r.height()来获取尺寸。&lt;/p&gt;

&lt;p&gt;那么文字的偏移就好说了，比如说你要把文字画在Canvas的左上角，坐标是(0,0)，但是当你通过：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;canvas.drawText(“dangwen”,0,0,paint);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;来画文字的时候，发现只有文字的下半部分画出来了，因为你传递进去的参数应该是以Baseline为标准的，正确的方法是：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;canvas.drawText(“dangwen”,-r.left,-r.top,paint);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Paint.getFontMetricsInt(): 当你通过这里方法来获取尺寸的时候，你获取的只是一个垂直方向上的尺寸，这里的ascent代表的是字体的上部，descent代表的是字体的下部，这里需要注意的是这和上面获得的Rect的top和bottom不太一样，他们比比ascent和descent距离稍微小一些，这些具体的高度可能和不同的字体和渲染方式有关系，这里就不深入了 #我是不懂#。&lt;/p&gt;

&lt;p&gt;然后如果把文字写入TextView（图中蓝色部分）并且设置TextView的高度和宽度设为wrap_content，那么TextView的高度就正好是FontMetricsInt.top – FontMetricsInt.bottom, 那宽度呢？ Paint.measureText()。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;



</content>
   </entry>
   
   <entry>
     <title>android中如何高效的使用alpha属性</title>
     <link href="http://beiyuu.com/android-Alpha"/>
     <updated>2014-12-07T00:00:00+08:00</updated>
     <id>http://beiyuu.com/android-Alpha</id>
     <content type="html">&lt;h2&gt;#&lt;/h2&gt;

&lt;p&gt;Alpha是图形界面开发中常用的特效，通常我们会使用以下代码来实现Alpha特效：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;view.setAlpha(0.5f);
    View.ALPHA.set(view, 0.5f);
    ObjectAnimator.ofFloat(view, &amp;quot;alpha&amp;quot;, 0.5f).start();
    view.animate().alpha(0.5f).start();
    view.setAnimation(new AlphaAnimation(1.0f, 0.5f));&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其效果都等同于：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;canvas.saveLayer(l, r, t, b, 127, Canvas.CLIP_TO_LAYER_SAVE_FLAG);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所以常见的alpha特效是通过将图像绘制到offscreen buffer中然后显示出来，这样的操作是非常消耗资源的，甚至可能导致性能问题，在开发过程中我们可以通过其他方式避免创建offsreen buffer。&lt;/p&gt;

&lt;h3&gt;TextView&lt;/h3&gt;

&lt;p&gt;对于TextView我们通常需要文字透明效果，而不是View本身透明，所以，直接设置带有alpha值的TextColor是比较高效的方式。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;// Not this
    textView.setAlpha(alpha);
    
    // 以下方式可以避免创建 offscreen buffer
    int newTextColor = (int) (0xFF * alpha) &amp;lt;&amp;lt; 24 | baseTextColor &amp;amp; 0xFFFFFF;
    textView.setTextColor(newTextColor);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;ImageView&lt;/h3&gt;

&lt;p&gt;同样的对于只具有src image的ImageView，直接调用setImageAlpha()方法更为合理。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;// Not this, setAlpha方法由View继承而来，性能不佳
    imageView.setAlpha(0.5f);

    // 使用以下方式时，ImageView会在绘制图片时单独为图片指定Alpha
    // 可以避免创建 offScreenBuffer
    imageView.setImageAlpha((int) alpha * 255);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;CustomView&lt;/h3&gt;

&lt;p&gt;类似的，自定义控件时，应该直接去设置paint的alpha。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;// Not this
    customView.setAlpha(alpha);

    // But this
    paint.setAlpha((int) alpha * 255);
    canvas.draw*(..., paint);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同时Android提供了hasOverlappingRendering()接口，通过重写该接口可以告知系统当前View是否存在内容重叠的情况，帮助系统优化绘制流程，原理是这样的：对于有重叠内容的View，系统简单粗暴的使用 offscreen buffer来协助处理。当告知系统该View无重叠内容时，系统会分别使用合适的alpha值绘制每一层。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;/**
 * Returns whether this View has content which overlaps. This function, intended to be
 * overridden by specific View types, is an optimization when alpha is set on a view. If
 * rendering overlaps in a view with alpha &amp;lt; 1, that view is drawn to an offscreen buffer
 * and then composited it into place, which can be expensive. If the view has no overlapping
 * rendering, the view can draw each primitive with the appropriate alpha value directly.
 * An example of overlapping rendering is a TextView with a background image, such as a
 * Button. An example of non-overlapping rendering is a TextView with no background, or
 * an ImageView with only the foreground image. The default implementation returns true;
 * subclasses should override if they have cases which can be optimized.
 *
 * @return true if the content in this view might overlap, false otherwise.
 */
public boolean hasOverlappingRendering() {
    return true;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后引用Chet Haase的一句话作为总结&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;“You know what your view is doing, so do the right thing for your situation.”&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;http://blog.csdn.net/guolin_blog/article/details/16330267&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>android的View绘制</title>
     <link href="http://beiyuu.com/view"/>
     <updated>2014-11-28T00:00:00+08:00</updated>
     <id>http://beiyuu.com/view</id>
     <content type="html">&lt;h3&gt;遇到的问题&lt;/h3&gt;

&lt;p&gt;https://developer.android.com/tools/sdk/ndk/index.html#Installing&lt;/p&gt;

&lt;h3&gt;关于View被绘制到屏幕的过程&lt;/h3&gt;

&lt;h2&gt;onMeasure()&lt;/h2&gt;

&lt;p&gt;measure是测量的意思，那么onMeasure()方法顾名思义就是用于测量视图的大小的。View系统的绘制流程会从ViewRoot的performTraversals()方法中开始，在其内部调用View的measure()方法。measure()方法接收两个参数，widthMeasureSpec和heightMeasureSpec，这两个值分别用于确定视图的宽度和高度的规格和大小。&lt;/p&gt;

&lt;p&gt;MeasureSpec的值由specSize和specMode共同组成的，其中specSize记录的是大小，specMode记录的是规格。specMode一共有三种类型，如下所示:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;EXACTLY
表示父视图希望子视图的大小应该是由specSize的值来决定的，系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AT_MOST
表示子视图最多只能是specSize中指定的大小，开发人员应该尽可能小得去设置这个视图，并且保证不会超过specSize。系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;UNSPECIFIED
表示开发人员可以将视图按照自己的意愿设置成任意的大小，没有任何限制。这种情况比较少见，不太会用到。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;那么你可能会有疑问了，widthMeasureSpec和heightMeasureSpec这两个值又是从哪里得到的呢？通常情况下，这两个值都是由父视图经过计算后传递给子视图的，说明父视图会在一定程度上决定子视图的大小。但是最外层的根视图，它的widthMeasureSpec和heightMeasureSpec又是从哪里得到的呢？这就需要去分析ViewRoot中的源码了，观察performTraversals()方法可以发现如下代码：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width); 
    childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，这里调用了getRootMeasureSpec()方法去获取widthMeasureSpec和heightMeasureSpec的值，注意方法中传入的参数，其中lp.width和lp.height在创建ViewGroup实例的时候就被赋值了，它们都等于MATCH_PARENT。然后看下getRootMeasureSpec()方法中的代码，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;private int getRootMeasureSpec(int windowSize, int rootDimension) {
    int measureSpec;
    switch (rootDimension) {
    case ViewGroup.LayoutParams.MATCH_PARENT:
        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
        break;
    case ViewGroup.LayoutParams.WRAP_CONTENT:
        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
        break;
    default:
        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
        break;
    }
    return measureSpec;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，这里使用了MeasureSpec.makeMeasureSpec()方法来组装一个MeasureSpec，当rootDimension参数等于MATCH_PARENT的时候，MeasureSpec的specMode就等于EXACTLY，当rootDimension等于WRAP_CONTENT的时候，MeasureSpec的specMode就等于AT_MOST。并且MATCH_PARENT和WRAP_CONTENT时的specSize都是等于windowSize的，也就意味着根视图总是会充满全屏的。&lt;/p&gt;

&lt;p&gt;介绍了这么多MeasureSpec相关的内容，接下来我们看下View的measure()方法里面的代码吧，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
    if ((mPrivateFlags &amp;amp; FORCE_LAYOUT) == FORCE_LAYOUT ||
            widthMeasureSpec != mOldWidthMeasureSpec ||
            heightMeasureSpec != mOldHeightMeasureSpec) {
        mPrivateFlags &amp;amp;= ~MEASURED_DIMENSION_SET;
        if (ViewDebug.TRACE_HIERARCHY) {
            ViewDebug.trace(this, ViewDebug.HierarchyTraceType.ON_MEASURE);
        }
        onMeasure(widthMeasureSpec, heightMeasureSpec);
        if ((mPrivateFlags &amp;amp; MEASURED_DIMENSION_SET) != MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(&amp;quot;onMeasure() did not set the&amp;quot;
                    + &amp;quot; measured dimension by calling&amp;quot;
                    + &amp;quot; setMeasuredDimension()&amp;quot;);
        }
        mPrivateFlags |= LAYOUT_REQUIRED;
    }
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意观察，measure()这个方法是final的，因此我们无法在子类中去重写这个方法，说明Android是不允许我们改变View的measure框架的。然后在第9行调用了onMeasure()方法，这里才是真正去测量并设置View大小的地方，默认会调用getDefaultSize()方法来获取视图的大小，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public static int getDefaultSize(int size, int measureSpec) {
    int result = size;
    int specMode = MeasureSpec.getMode(measureSpec);
    int specSize = MeasureSpec.getSize(measureSpec);
    switch (specMode) {
    case MeasureSpec.UNSPECIFIED:
        result = size;
        break;
    case MeasureSpec.AT_MOST:
    case MeasureSpec.EXACTLY:
        result = specSize;
        break;
    }
    return result;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里传入的measureSpec是一直从measure()方法中传递过来的。然后调用MeasureSpec.getMode()方法可以解析出specMode，调用MeasureSpec.getSize()方法可以解析出specSize。接下来进行判断，如果specMode等于AT_MOST或EXACTLY就返回specSize，这也是系统默认的行为。之后会在onMeasure()方法中调用setMeasuredDimension()方法来设定测量出的大小，这样一次measure过程就结束了。&lt;/p&gt;

&lt;p&gt;当然，一个界面的展示可能会涉及到很多次的measure，因为一个布局中一般都会包含多个子视图，每个视图都需要经历一次measure过程。ViewGroup中定义了一个measureChildren()方法来去测量子视图的大小，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
    final int size = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i &amp;lt; size; ++i) {
        final View child = children[i];
        if ((child.mViewFlags &amp;amp; VISIBILITY_MASK) != GONE) {
            measureChild(child, widthMeasureSpec, heightMeasureSpec);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，在第4行和第6行分别调用了getChildMeasureSpec()方法来去计算子视图的MeasureSpec，计算的依据就是布局文件中定义的MATCH_PARENT、WRAP_CONTENT等值，这个方法的内部细节就不再贴出。然后在第8行调用子视图的measure()方法，并把计算出的MeasureSpec传递进去，之后的流程就和前面所介绍的一样了。&lt;/p&gt;

&lt;p&gt;当然，onMeasure()方法是可以重写的，也就是说，如果你不想使用系统默认的测量方式，可以按照自己的意愿进行定制，比如：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class MyView extends View {

    ......
    
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(200, 200);
    }

    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样的话就把View默认的测量流程覆盖掉了，不管在布局文件中定义MyView这个视图的大小是多少，最终在界面上显示的大小都将会是200*200。&lt;/p&gt;

&lt;p&gt;需要注意的是，在setMeasuredDimension()方法调用之后，我们才能使用getMeasuredWidth()和getMeasuredHeight()来获取视图测量出的宽高，以此之前调用这两个方法得到的值都会是0。&lt;/p&gt;

&lt;p&gt;由此可见，视图大小的控制是由父视图、布局文件、以及视图本身共同完成的，父视图会提供给子视图参考的大小，而开发人员可以在XML文件中指定视图的大小，然后视图本身会对最终的大小进行拍板。&lt;/p&gt;

&lt;h2&gt;onLayout()&lt;/h2&gt;

&lt;p&gt;measure过程结束后，视图的大小就已经测量好了，接下来就是layout的过程了。正如其名字所描述的一样，这个方法是用于给视图进行布局的，也就是确定视图的位置。ViewRoot的performTraversals()方法会在measure结束后继续执行，并调用View的layout()方法来执行此过程，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;host.layout(0, 0, host.mMeasuredWidth, host.mMeasuredHeight);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;layout()方法接收四个参数，分别代表着左、上、右、下的坐标，当然这个坐标是相对于当前视图的父视图而言的。可以看到，这里还把刚才测量出的宽度和高度传到了layout()方法中。那么我们来看下layout()方法中的代码是什么样的吧，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public void layout(int l, int t, int r, int b) {
    int oldL = mLeft;
    int oldT = mTop;
    int oldB = mBottom;
    int oldR = mRight;
    boolean changed = setFrame(l, t, r, b);
    if (changed || (mPrivateFlags &amp;amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) {
        if (ViewDebug.TRACE_HIERARCHY) {
            ViewDebug.trace(this, ViewDebug.HierarchyTraceType.ON_LAYOUT);
        }
        onLayout(changed, l, t, r, b);
        mPrivateFlags &amp;amp;= ~LAYOUT_REQUIRED;
        if (mOnLayoutChangeListeners != null) {
            ArrayList&amp;lt;OnLayoutChangeListener&amp;gt; listenersCopy =
                    (ArrayList&amp;lt;OnLayoutChangeListener&amp;gt;) mOnLayoutChangeListeners.clone();
            int numListeners = listenersCopy.size();
            for (int i = 0; i &amp;lt; numListeners; ++i) {
                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);
            }
        }
    }
    mPrivateFlags &amp;amp;= ~FORCE_LAYOUT;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在layout()方法中，首先会调用setFrame()方法来判断视图的大小是否发生过变化，以确定有没有必要对当前的视图进行重绘，同时还会在这里把传递过来的四个参数分别赋值给mLeft、mTop、mRight和mBottom这几个变量。接下来会在第11行调用onLayout()方法，正如onMeasure()方法中的默认行为一样，也许你已经迫不及待地想知道onLayout()方法中的默认行为是什么样的了。进入onLayout()方法，咦？怎么这是个空方法，一行代码都没有？！&lt;/p&gt;

&lt;p&gt;没错，View中的onLayout()方法就是一个空方法，因为onLayout()过程是为了确定视图在布局中所在的位置，而这个操作应该是由布局来完成的，即父视图决定子视图的显示位置。既然如此，我们来看下ViewGroup中的onLayout()方法是怎么写的吧，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Override
    protected abstract void onLayout(boolean changed, int l, int t, int r, int b);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，ViewGroup中的onLayout()方法竟然是一个抽象方法，这就意味着所有ViewGroup的子类都必须重写这个方法。没错，像LinearLayout、RelativeLayout等布局，都是重写了这个方法，然后在内部按照各自的规则对子视图进行布局的。由于LinearLayout和RelativeLayout的布局规则都比较复杂，就不单独拿出来进行分析了，这里我们尝试自定义一个布局，借此来更深刻地理解onLayout()的过程。&lt;/p&gt;

&lt;p&gt;自定义的这个布局目标很简单，只要能够包含一个子视图，并且让子视图正常显示出来就可以了。那么就给这个布局起名叫做SimpleLayout吧，代码如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class SimpleLayout extends ViewGroup {

    public SimpleLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        if (getChildCount() &amp;gt; 0) {
            View childView = getChildAt(0);
            measureChild(childView, widthMeasureSpec, heightMeasureSpec);
        }
    }

    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        if (getChildCount() &amp;gt; 0) {
            View childView = getChildAt(0);
            childView.layout(0, 0, childView.getMeasuredWidth(), childView.getMeasuredHeight());
        }
    }

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;代码非常的简单，我们来看下具体的逻辑吧。你已经知道，onMeasure()方法会在onLayout()方法之前调用，因此这里在onMeasure()方法中判断SimpleLayout中是否有包含一个子视图，如果有的话就调用measureChild()方法来测量出子视图的大小。&lt;/p&gt;

&lt;p&gt;接着在onLayout()方法中同样判断SimpleLayout是否有包含一个子视图，然后调用这个子视图的layout()方法来确定它在SimpleLayout布局中的位置，这里传入的四个参数依次是0、0、childView.getMeasuredWidth()和childView.getMeasuredHeight()，分别代表着子视图在SimpleLayout中左上右下四个点的坐标。其中，调用childView.getMeasuredWidth()和childView.getMeasuredHeight()方法得到的值就是在onMeasure()方法中测量出的宽和高。&lt;/p&gt;

&lt;p&gt;这样就已经把SimpleLayout这个布局定义好了，下面就是在XML文件中使用它了，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&amp;lt;com.example.viewtest.SimpleLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot; &amp;gt;
    
    &amp;lt;ImageView 
        android:layout_width=&amp;quot;wrap_content&amp;quot;
        android:layout_height=&amp;quot;wrap_content&amp;quot;
        android:src=&amp;quot;@drawable/ic_launcher&amp;quot;
        /&amp;gt;
    
    &amp;lt;/com.example.viewtest.SimpleLayout&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在onLayout()过程结束后，我们就可以调用getWidth()方法和getHeight()方法来获取视图的宽高了。说到这里，我相信很多朋友长久以来都会有一个疑问，getWidth()方法和getMeasureWidth()方法到底有什么区别呢？它们的值好像永远都是相同的。其实它们的值之所以会相同基本都是因为布局设计者的编码习惯非常好，实际上它们之间的差别还是挺大的。&lt;/p&gt;

&lt;p&gt;首先getMeasureWidth()方法在measure()过程结束后就可以获取到了，而getWidth()方法要在layout()过程结束后才能获取到。另外，getMeasureWidth()方法中的值是通过setMeasuredDimension()方法来进行设置的，而getWidth()方法中的值则是通过视图右边的坐标减去左边的坐标计算出来的。&lt;/p&gt;

&lt;p&gt;观察SimpleLayout中onLayout()方法的代码，这里给子视图的layout()方法传入的四个参数分别是0、0、childView.getMeasuredWidth()和childView.getMeasuredHeight()，因此getWidth()方法得到的值就是childView.getMeasuredWidth() - 0 = childView.getMeasuredWidth() ，所以此时getWidth()方法和getMeasuredWidth() 得到的值就是相同的，但如果你将onLayout()方法中的代码进行如下修改：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
    if (getChildCount() &amp;gt; 0) {
        View childView = getChildAt(0);
        childView.layout(0, 0, 200, 200);
    }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样getWidth()方法得到的值就是200 - 0 = 200，不会再和getMeasuredWidth()的值相同了。当然这种做法充分不尊重measure()过程计算出的结果，通常情况下是不推荐这么写的。getHeight()与getMeasureHeight()方法之间的关系同上，就不再重复分析了。&lt;/p&gt;

&lt;h2&gt;onDraw()&lt;/h2&gt;

&lt;p&gt;measure和layout的过程都结束后，接下来就进入到draw的过程了。同样，根据名字你就能够判断出，在这里才真正地开始对视图进行绘制。ViewRoot中的代码会继续执行并创建出一个Canvas对象，然后调用View的draw()方法来执行具体的绘制工作。draw()方法内部的绘制过程总共可以分为六步，其中第二步和第五步在一般情况下很少用到，因此这里我们只分析简化后的绘制过程。代码如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public void draw(Canvas canvas) {
    if (ViewDebug.TRACE_HIERARCHY) {
        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
    }
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags &amp;amp; DIRTY_MASK) == DIRTY_OPAQUE &amp;amp;&amp;amp;
            (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags &amp;amp; ~DIRTY_MASK) | DRAWN;
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        final Drawable background = mBGDrawable;
        if (background != null) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            if (mBackgroundSizeChanged) {
                background.setBounds(0, 0,  mRight - mLeft, mBottom - mTop);
                mBackgroundSizeChanged = false;
            }
            if ((scrollX | scrollY) == 0) {
                background.draw(canvas);
            } else {
                canvas.translate(scrollX, scrollY);
                background.draw(canvas);
                canvas.translate(-scrollX, -scrollY);
            }
        }
    }
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags &amp;amp; FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags &amp;amp; FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges &amp;amp;&amp;amp; !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque) onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        // Step 6, draw decorations (scrollbars)
        onDrawScrollBars(canvas);
        // we&amp;#39;re done...
        return;
    }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，第一步是从第9行代码开始的，这一步的作用是对视图的背景进行绘制。这里会先得到一个mBGDrawable对象，然后根据layout过程确定的视图位置来设置背景的绘制区域，之后再调用Drawable的draw()方法来完成背景的绘制工作。那么这个mBGDrawable对象是从哪里来的呢？其实就是在XML中通过android:background属性设置的图片或颜色。当然你也可以在代码中通过setBackgroundColor()、setBackgroundResource()等方法进行赋值。&lt;/p&gt;

&lt;p&gt;接下来的第三步是在第34行执行的，这一步的作用是对视图的内容进行绘制。可以看到，这里去调用了一下onDraw()方法，那么onDraw()方法里又写了什么代码呢？进去一看你会发现，原来又是个空方法啊。其实也可以理解，因为每个视图的内容部分肯定都是各不相同的，这部分的功能交给子类来去实现也是理所当然的。&lt;/p&gt;

&lt;p&gt;第三步完成之后紧接着会执行第四步，这一步的作用是对当前视图的所有子视图进行绘制。但如果当前的视图没有子视图，那么也就不需要进行绘制了。因此你会发现View中的dispatchDraw()方法又是一个空方法，而ViewGroup的dispatchDraw()方法中就会有具体的绘制代码。&lt;/p&gt;

&lt;p&gt;以上都执行完后就会进入到第六步，也是最后一步，这一步的作用是对视图的滚动条进行绘制。那么你可能会奇怪，当前的视图又不一定是ListView或者ScrollView，为什么要绘制滚动条呢？其实不管是Button也好，TextView也好，任何一个视图都是有滚动条的，只是一般情况下我们都没有让它显示出来而已。绘制滚动条的代码逻辑也比较复杂，这里就不再贴出来了，因为我们的重点是第三步过程&lt;/p&gt;

&lt;p&gt;通过以上流程分析，相信大家已经知道，View是不会帮我们绘制内容部分的，因此需要每个视图根据想要展示的内容来自行绘制。如果你去观察TextView、ImageView等类的源码，你会发现它们都有重写onDraw()这个方法，并且在里面执行了相当不少的绘制逻辑。绘制的方式主要是借助Canvas这个类，它会作为参数传入到onDraw()方法中，供给每个视图使用。Canvas这个类的用法非常丰富，基本可以把它当成一块画布，在上面绘制任意的东西，那么我们就来尝试一下吧。&lt;/p&gt;

&lt;p&gt;这里简单起见，我只是创建一个非常简单的视图，并且用Canvas随便绘制了一点东西，代码如下所示：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class MyView extends View {

    private Paint mPaint;

    public MyView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        mPaint.setColor(Color.YELLOW);
        canvas.drawRect(0, 0, getWidth(), getHeight(), mPaint);
        mPaint.setColor(Color.BLUE);
        mPaint.setTextSize(20);
        String text = &amp;quot;Hello View&amp;quot;;
        canvas.drawText(text, 0, getHeight() / 2, mPaint);
    }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，我们创建了一个自定义的MyView继承自View，并在MyView的构造函数中创建了一个Paint对象。Paint就像是一个画笔一样，配合着Canvas就可以进行绘制了。这里我们的绘制逻辑比较简单，在onDraw()方法中先是把画笔设置成黄色，然后调用Canvas的drawRect()方法绘制一个矩形。然后在把画笔设置成蓝色，并调整了一下文字的大小，然后调用drawText()方法绘制了一段文字。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;http://blog.csdn.net/guolin_blog/article/details/16330267&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>android的NDK调试常见问题</title>
     <link href="http://beiyuu.com/ndk"/>
     <updated>2014-11-17T00:00:00+08:00</updated>
     <id>http://beiyuu.com/ndk</id>
     <content type="html">&lt;h3&gt;遇到的问题&lt;/h3&gt;

&lt;p&gt;https://developer.android.com/tools/sdk/ndk/index.html#Installing&lt;/p&gt;

&lt;h3&gt;用GDB进行so调试&lt;/h3&gt;

&lt;h2&gt;编译&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;要有没有strip的so
strip命令位置: toolchains/arm-linux-androideabi-4.6/prebuilt/linux-x86_64/arm-linux-androideabi/bin/strip 注意strip前要保留原来的so文件,以后调试时需要使用&lt;/li&gt;
&lt;li&gt;其他: 用nm命令 可以列出so内的符号,可以用于查看so是否有符号,如 nm xx.so&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;GDB 调试so&lt;/h2&gt;

&lt;p&gt;需要的文件:
gdbserver 位置:android-ndk-r8b/prebuilt/android-arm/gdbserver/gdbserver
gdb 位置:android-ndk-r8b/toolchains/arm-linux-androideabi-4.6/prebuilt/linux-x86/bin/arm-linux-androideabi-gdb
步骤:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;apk 打开调试开关, AndroidManifest.xml 中, application节点 加入 android:debuggable=&quot;true&quot;,&lt;/li&gt;
&lt;li&gt;如果是root的机器,apk没有打开调试开关也可以进行调试,如果是已经root的机器,把gdbserver放到系统(手机)的目录下(可以随意放置,一般放到system/bin目录下方便输入命令)&lt;/li&gt;
&lt;li&gt;如果是没有root的机器,需要把gdbserver打到apk的包里(放到lib目录下),这样安装apk的的时候会把gdbserver拷贝到/data/data/app名称/lib/gdbserver&lt;/li&gt;
&lt;li&gt;启动apk,可以直接启动&lt;/li&gt;
&lt;li&gt;用 adb shell 进行控制台,用ps命令查看app的进程id&lt;/li&gt;
&lt;li&gt;如果是root机器,可以su后,直接用gdbserver attach ,命令行是 gdbserver :端口号 --attach pid 如 : su gdbserver :2345 --attach pid&lt;/li&gt;
&lt;li&gt;如果是未root机器,只能用以下方式 run-as app名称 lib/gdbserver :端口号 --attach pid&lt;/li&gt;
&lt;li&gt;在pc上运行adb forward tcp:端口号(指PC上的端口) tcp:端口号(手机上的端口) 建立端口映射&lt;/li&gt;
&lt;li&gt;把/system/bin/app_process /system/bin/linker, /system/lib/libc.so 从手机上拷贝出来(可以用adb pull 命令),其他so文件也拷贝出来也行,我们假定拷贝的目录为$lib&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行arm-linux-androideabi-gdb ,输入以下命令序列
file $lib/app_process $lib目录中有从手机拷贝出来的app_process,linker和libc.so这些文件 ,如我放到了/home/qrf/android_ndk_debug/mydev目录下&lt;/p&gt;

&lt;p&gt;set solib-absolute-prefix $nostriplib_dir $nostriplib_dir是存放了没有strip的so的目录,如 set solib-absolute-prefix /home/qrf/code/cmso&lt;/p&gt;

&lt;p&gt;set solib-search-path $lib:$nostriplib_dir 如set solib-search-path /home/qrf/android_ndk_debug/mydev:/home/qrf/code/cmso&lt;/p&gt;

&lt;p&gt;target remote :端口号 连上gdbserver&lt;/p&gt;

&lt;p&gt;dir source 指定源码路径
后面就是gdb调试的问题了,进入gdb调试界面可以用ctrl x + a 来切换到&lt;strong&gt;&lt;em&gt;文本模式&lt;/em&gt;&lt;/strong&gt;(可以查看源码), 如果要配合ddd前端, 用apt-get install ddd ,然后 用ddd --debugger arm-linux-androideabi-gdb 使用,但是ddd有时会不太灵光,还是直接使用gdb比较方便&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;附一些常用的gdb命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;backtrace/bt    //列出当前线程堆栈

thread apply all bt //列出所有线程调用堆栈

thread 线程号//切换线程上下文

ctrl x+a //切换到源码浏览窗口 ，再按ctrl x+a 切换回去

ctrl c //中断当前运行

c/continue //继续运行

info sharedlibrary //列出so加载列表

info threads //列出线程列表

info locals //列出当前堆栈上的局部变量

info breakpoints //列出断点

print 变量名 //列出变量内容 

print 变量名= //修改变量名的值

b/break 源码文件名:行号 //下断点

d/delete 断点id //删除断点

f/frame 栈帧序号 //切换到指定的栈帧 如 f 0 顶层

s/step //下一步，有函数调用会进入

n/next //下一步，有函数调用不会进入

fin/finish //返回到上层函数调用

disable 断点id  //禁用断点

enable 断点id  //启用断点

disassemble/disas //查看汇编代码
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>git和SVN配合</title>
     <link href="http://beiyuu.com/git-svn"/>
     <updated>2014-11-16T00:00:00+08:00</updated>
     <id>http://beiyuu.com/git-svn</id>
     <content type="html">&lt;h3&gt;使用Git有什么方便的？&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;把大修改点拆小提交记录。&lt;/li&gt;
&lt;li&gt;随时更新服务器代码到本地，不影响当前工作环境。&lt;/li&gt;
&lt;li&gt;连不上服务器时，也能正常工作。&lt;/li&gt;
&lt;li&gt;数据分布式存放，数据丢失的可能性最小。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;推荐读物 Pro Git&lt;/h3&gt;

&lt;h3&gt;常用命令&lt;/h3&gt;

&lt;table class=&quot;wiki&quot;&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;说明&lt;/strong&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git svn clone -s http://svn.repo.url&lt;/td&gt;&lt;td&gt;从远程SVN服务器下拉所有代码变化到本地(SVN目录必须符合标准，有trunk, tags, branches，否则把-s选项去掉)
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git svn fetch&lt;/td&gt;&lt;td&gt;从远程SVN服务器下拉代码变化到本地Git服务端
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git svn dcommit&lt;/td&gt;&lt;td&gt;把本地Git服务端的代码变化，同步提交到远程SVN服务器
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git branch&lt;/td&gt;&lt;td&gt;查看本地分支列表
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git branch -a&lt;/td&gt;&lt;td&gt;查看所有分支列表
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git branch -d branchName&lt;/td&gt;&lt;td&gt;删除本地分支
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git branch -D branchName&lt;/td&gt;&lt;td&gt;强制删除本地分支
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git checkout -b locBranchName remotes/branchName&lt;/td&gt;&lt;td&gt;从远程(其实就是本机的git服务端)分支创建一个本地分支，并将工作目录切换到这个本地分支
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git checkout locBranchName&lt;/td&gt;&lt;td&gt;把工作目录切换到一个已存在的本地分支
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git checkout *&lt;/td&gt;&lt;td&gt;把工作目录内没有提交的所有修改恢复原样，相当于svn的revert操作
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git clean -n&lt;/td&gt;&lt;td&gt;查看有什么多余的文件可以清理的
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git clean -f&lt;/td&gt;&lt;td&gt;清理多余的文件
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git gui&lt;/td&gt;&lt;td&gt;git提供的一个图形界面工具，常用来提交代码
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;gitk&lt;/td&gt;&lt;td&gt;git的一个图形界面工具，常用来查看日志及变化
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git rebase remotes/branchName&lt;/td&gt;&lt;td&gt;把远程(其实就是本机的git服务端)分支的最新变更合并到本地分支
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git cherry-pick {SHA1-ID}&lt;/td&gt;&lt;td&gt;把指定SHA1 ID的修改点合并到当前本地分支
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git diff&lt;/td&gt;&lt;td&gt;查看变化
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git difftool -t meld -y&lt;/td&gt;&lt;td&gt;用meld查看变化
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;git mergetool -t meld -y&lt;/td&gt;&lt;td&gt;用meld合并解决冲突代码
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;



</content>
   </entry>
   
 
</feed>
